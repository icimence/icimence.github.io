<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>icimence&#39;s Tech Blog</title>
  
  
  <link href="https://icimence.cn/atom.xml" rel="self"/>
  
  <link href="https://icimence.cn/"/>
  <updated>2023-04-05T16:47:36.394Z</updated>
  <id>https://icimence.cn/</id>
  
  <author>
    <name>icimence</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kubernetes学习笔记（一）</title>
    <link href="https://icimence.cn/2023/04/05/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://icimence.cn/2023/04/05/kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-04-05T14:08:57.000Z</published>
    <updated>2023-04-05T16:47:36.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><p>在一个kubernetes集群中所包含的组件内容</p><p><img src="https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg" alt="Components of Kubernetes"></p><p>Pod是一个k8s独有的概念，可以表示封装一个或者多个的容器，更加强调这是一个运行环境，而不是指一个强调提供应用程序运行的容器。且Pod提供一个共享的命名空间和存储卷，在一个Pod中的容器之间可以非常方便的进行通讯。Pod是k8s最小的调度单位。</p><h3 id="Control-Plane组件介绍"><a href="#Control-Plane组件介绍" class="headerlink" title="Control Plane组件介绍"></a>Control Plane组件介绍</h3><h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>该组件是Kubernetes API Server的主要实现，而Kubernetes API Server则负责暴露集群的接口，是control plane的前端。可以通过部署多个apiserver实例来进行负载均衡。</p><h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p>提供高可用并且一致性的键值对存储，作为Kuberntes的后台数据库，但是需要保证有<a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">数据备份</a>。</p><h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>负责将创建出来的pod（可以理解为运行的容器）指派到node（集群中的机器）。</p><p>在安排的过程中的影响因素主要有：</p><ul><li>单个pod或者多个pod的资源需求</li><li>软硬件的约束策略</li><li>亲和性和反亲和性的规范</li><li>数据位置</li><li>工作负载</li><li>deadline</li></ul><h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>负责运行contoller（用于从apiserver获取当前集群状态，同时尝试将当前集群状态转移到期望的集群状态）进程。</p><p>controller可以分为以下这些：</p><ol><li>Node controller：当node挂掉时负责通知和响应</li><li>Job controller：检测代表一次性任务的Job对象，然后创建Pods来运行这些任务直到完成。</li><li>EndPointSlice controller： 提供Service和Pod之间的连接</li><li>ServiceAccount controller： 为新的命名空间创建默认的服务账号</li></ol><h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h4><p>它可以使用云提供商提供的接口，将控制平面在自己机器上部署，同时通过一系列的API将node部署在云提供商的服务器中。</p><h3 id="Node组件介绍"><a href="#Node组件介绍" class="headerlink" title="Node组件介绍"></a>Node组件介绍</h3><p>node就是运行节点，负责维护运行的Pod并提供Kubernetes运行环境</p><h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>保证容器正常运行在Pod中，接受指定的PodSpec（指定的一些容器规格，比如说镜像，命令，参数，环境变量等等）、</p><h4 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h4><p>负责node上的网络代理，实现了一部分的服务，维护一些node上的网络规则（集群内部或者外部的与pod之间的网络通信）</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>大部分的k8s集群还是需要DNS做解析的。</p><h4 id="DashBoard"><a href="#DashBoard" class="headerlink" title="DashBoard"></a>DashBoard</h4><p>仪表盘，可以使用Web用户界面管理集群中的应用程序以及集群本身</p><h4 id="Cluster-level-Logging"><a href="#Cluster-level-Logging" class="headerlink" title="Cluster-level Logging"></a>Cluster-level Logging</h4><p>集群日志可以将所有的容器日志进行汇总，并且提供一个中心化的访问查询接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件介绍&quot;&gt;&lt;a href=&quot;#组件介绍&quot; class=&quot;headerlink&quot; title=&quot;组件介绍&quot;&gt;&lt;/a&gt;组件介绍&lt;/h2&gt;&lt;p&gt;在一个kubernetes集群中所包含的组件内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://d33wubrfki0l</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="kubernetes" scheme="https://icimence.cn/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer刷题笔记</title>
    <link href="https://icimence.cn/2022/10/22/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://icimence.cn/2022/10/22/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-10-21T16:48:42.000Z</published>
    <updated>2022-10-23T08:04:01.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>因为最近要找实习，行业形势还收紧，压力巨大，所以打算奋起刷题，暂时把剑指Offer第一部分的刷题感想放在这里。本文不给出标准答案，便于根据思路编写代码。（本人是菜鸡，希望有人指正错误，别再给菜狗上压力了）。</p><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>题目很简洁，使用两个栈实现一个队列，两个方法，一个是向队列尾部添加元素，一个是从队列头部取出元素。</p><h3 id="我自己的解答"><a href="#我自己的解答" class="headerlink" title="我自己的解答"></a>我自己的解答</h3><blockquote><p>我自己的方法是一个stack存储数据，另一个stack完全用来辅助，插入时插入进数据队列中，取出时将所有的数据栈中的取出并压入第二个stack中，最后拿到栈底元素，重新将所有的第二个stack中的元素取出并压入第一个stack</p><p>我自己的这个方法就是相当于每次都是把整个栈清空了一次并且重新写入，显然是效率非常低的方法</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题解首先使用一个stack用来存储所有的数据，加入时直接压栈，取出时首先判断另一个stack是否为空，如果是空的将第一个stack中的所有元素取出并</p><p>压入第二个stack中，所以只要是出队列首先检查第二个stack是否还有元素，如果没有，则重新从第一个stack中进行倒序入栈的操作。<a href="[用两个栈实现队列 - 用两个栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/">代码链接</a>)</p><h2 id="30"><a href="#30" class="headerlink" title="30"></a>30</h2><p>题目也比较简单，实现一个栈，可以在O(1)时间内完成push和pop和min三个函数</p><h3 id="我自己的解答-1"><a href="#我自己的解答-1" class="headerlink" title="我自己的解答"></a>我自己的解答</h3><blockquote><p>首先可以很容易注意到push和pop是不需要注意的，因为这两个操作本身就是O(1)，min因为要求O(1)所以一定需要有一个额外的数据结构存储最小值，考虑到需要在出栈之后保存正确的最小数结果，可以使用另一个栈记录每一个元素在压入时对应的最小值，在元素出栈时压入的最小值也一同出栈即可。</p></blockquote><p>思路与题解一致，不再展示题解的解法</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>题目要求从尾到头打印一个单向链表</p><h3 id="我自己的解答-2"><a href="#我自己的解答-2" class="headerlink" title="我自己的解答"></a>我自己的解答</h3><blockquote><p>我使用了一个List用来存储顺序的结果，然后使用循环倒序输出</p></blockquote><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>这种题目从正序变为倒序需要直接想到stack</p><h3 id="24"><a href="#24" class="headerlink" title="24"></a>24</h3><p>题目要求反转一个链表，本题实在是过于简单不描述了，答案的代码略优，可以免去输入为空的特殊情况讨论，直接放答案在这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/fan-zhuan-lian-biao-by-leetcode-solution-jvs5/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;因为最近要找实习，行业形势还收紧，压力巨大，所以打算奋起刷题，暂时把剑指Offer第一部分的刷题感想放在这里。本文不给出标准答案，便于根据思</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://icimence.cn/tags/LeetCode/"/>
    
    <category term="Dynamic Programming" scheme="https://icimence.cn/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>算法红书笔记</title>
    <link href="https://icimence.cn/2022/09/22/%E7%AE%97%E6%B3%95%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://icimence.cn/2022/09/22/%E7%AE%97%E6%B3%95%E7%BA%A2%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-09-22T13:56:44.000Z</published>
    <updated>2022-10-03T18:10:32.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>算法大多和使用的编程语言无关，学习算法的主要原因是因为能够节省非常多资源，通常比直接使用金钱购买更好的硬件设备拥有更好的效果。</p><h2 id="算法代码示例"><a href="#算法代码示例" class="headerlink" title="算法代码示例"></a>算法代码示例</h2><h3 id="最大公约数（gcd）"><a href="#最大公约数（gcd）" class="headerlink" title="最大公约数（gcd）"></a>最大公约数（gcd）</h3><p>欧几里得算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="number">0</span>)<span class="keyword">return</span> q;</span><br><span class="line">    <span class="keyword">int</span> r  = p % q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;p&gt;算法大多和使用的编程语言无关，学习算法的主要原因是因为能够节省非常多资源，通常比直接使用金钱购买更好的硬件设备拥有更好的效果。&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Algorithm" scheme="https://icimence.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语法参考</title>
    <link href="https://icimence.cn/2022/02/27/MySQL%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/"/>
    <id>https://icimence.cn/2022/02/27/MySQL%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/</id>
    <published>2022-02-26T16:40:16.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>因为学习过程中发现很容易遗忘MySQL语法所以在这里记录一下，同时这里的描述会同步到<a href="https://learn.icimence.cn">我的面试网站</a>中。</p><h2 id="MySQL查询"><a href="#MySQL查询" class="headerlink" title="MySQL查询"></a>MySQL查询</h2><p>查询是各个考察过程中最喜欢的考点，下面整理出常用的查询语法供参考</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;因为学习过程中发现很容易遗忘MySQL语法所以在这里记录一下，同时这里的描述会同步到&lt;a href=&quot;https://learn.icime</summary>
      
    
    
    
    <category term="问题解决" scheme="https://icimence.cn/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
    <category term="MySQL" scheme="https://icimence.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第39题分析</title>
    <link href="https://icimence.cn/2022/02/26/LeetCode%E7%AC%AC39%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>https://icimence.cn/2022/02/26/LeetCode%E7%AC%AC39%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2022-02-26T06:58:43.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p><p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= candidates.length &lt;= 30</li><li>1 &lt;= candidates[i] &lt;= 200</li><li>candidate 中的每个元素都 互不相同</li><li>1 &lt;= target &lt;= 500</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum">https://leetcode-cn.com/problems/combination-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本不用想就知道要使用递归，同时通过进一步的思考会发现如果使用递归算法将会产生大量的冗余计算，首先进入我的想法的是带存储器的递归，通过hashMap来避免重复计算。重新仔细阅读题目，发现hashMap在这个环境中不能正常工作，因为往往针对一个target有多种解法并不是一对一的关系。</p><p>分析题目可以发现递归过程可以作为一棵树，而这棵树中重复的节点是由于在产生子节点的时候考虑了所有的侯选数，只要按顺序考虑候选数就可以在不重复的前提下保证计算到所有的情况，如图：</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/leetcode/39-1.png" alt=""></p><p>接下来就可以写出对应的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">question39</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (candidates.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            Deque&lt;Integer&gt; tempRes = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">            dfs(candidates, target, <span class="number">0</span>, tempRes, res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, Deque&lt;Integer&gt; tempRes, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempRes));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                tempRes.addLast(candidates[i]);</span><br><span class="line">                dfs(candidates,target-candidates[i],i,tempRes,res);</span><br><span class="line">                tempRes.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>有了上面的代码这道题其实已经解决，但是上面的代码尚有优化空间，若candidates能够有序排列就可以做到在前一项加和已经过大时中断枚举过程省去后续的计算步骤。</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">question39</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (candidates.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            Deque&lt;Integer&gt; tempRes = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">            Arrays.sort(candidates); <span class="comment">//首先需要对candidates进行排序</span></span><br><span class="line">            dfs(candidates, target, <span class="number">0</span>, tempRes, res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, Deque&lt;Integer&gt; tempRes, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempRes));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[start]) <span class="comment">//如果首项已经过大则没有必要继续枚举</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                tempRes.addLast(candidates[i]);</span><br><span class="line">                dfs(candidates,target-candidates[i],i,tempRes,res);</span><br><span class="line">                tempRes.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">question39</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            HashMap&lt;List&lt;Integer&gt;,Integer&gt; allRes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (candidates.length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            Deque&lt;Integer&gt; tempRes = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">            Arrays.sort(candidates);</span><br><span class="line">            dfs(candidates, target, <span class="number">0</span>, tempRes, allRes);</span><br><span class="line">            res.addAll(allRes.keySet());</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, Deque&lt;Integer&gt; tempRes, HashMap&lt;List&lt;Integer&gt;,Integer&gt; allRes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(tempRes);</span><br><span class="line">                allRes.put(temp,allRes.getOrDefault(temp,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//                res.add(new ArrayList&lt;&gt;(tempRes));</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidates.length == start)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[start])</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                tempRes.addLast(candidates[i]);</span><br><span class="line">                dfs(candidates, target - candidates[i], i + <span class="number">1</span>, tempRes, allRes);</span><br><span class="line">                tempRes.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> ArrayDeque&lt;&gt;(len);</span><br><span class="line">        dfs(candidates, len, <span class="number">0</span>, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates 候选数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len        冗余变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin      从候选数组的 begin 位置开始搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target     表示剩余，这个值一开始等于 target，基于题目中说明的&quot;所有数字（包括目标数）都是正整数&quot;这个条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path       从根结点到叶子结点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> len, <span class="keyword">int</span> begin, <span class="keyword">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            <span class="comment">// 调试语句 ①</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;递归之前 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span></span><br><span class="line">            dfs(candidates, len, i + <span class="number">1</span>, target - candidates[i], path, res);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">// 调试语句 ②</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;递归之后 =&gt; &quot; + path + &quot;，剩余 = &quot; + (target - candidates[i]));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] candidates = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">8</span>;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = solution.combinationSum2(candidates, target);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出 =&gt; &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h2&gt;&lt;p&gt;给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://icimence.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>python虚拟环境</title>
    <link href="https://icimence.cn/2022/02/20/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://icimence.cn/2022/02/20/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2022-02-20T14:17:39.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>因为有人来问关于机器学习python环境的相关问题，就大致写一下</p><h2 id="python版本介绍"><a href="#python版本介绍" class="headerlink" title="python版本介绍"></a>python版本介绍</h2><p>这部分其实没啥好写的，下载的时候就能注意到python的版本，如果涉及到多个python版本的切换问题还是推荐使用<code>anaconda</code>作为开发的辅助工具。</p><h2 id="VirtualEnv介绍"><a href="#VirtualEnv介绍" class="headerlink" title="VirtualEnv介绍"></a>VirtualEnv介绍</h2><p>这是一个关键性的工具，其目的是搭建虚拟且独立的python环境，可以让每个项目环境独立，并保持环境的干净，最重要的就是解决包冲突的问题。</p><p>下面来介绍一下在各个平台对python的virtualenv的使用，所有平台都通过pip进行virtualenv的安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><p>之后就可以使用virtualenv实现虚拟环境的使用了</p><div class="tabs" id="virtualenv"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#virtualenv-1">Windows</button></li><li class="tab"><button type="button" data-href="#virtualenv-2">Linux</button></li><li class="tab"><button type="button" data-href="#virtualenv-3">MacOS</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="virtualenv-1"><p>以下代码是首次创建文件夹并创建虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir pythonTest</span><br><span class="line"><span class="built_in">cd</span> pythonTest</span><br><span class="line">virtualenv env</span><br></pre></td></tr></table></figure><p>要激活虚拟环境只需要在拥有虚拟环境的文件目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env/Scripts/activate</span><br></pre></td></tr></table></figure><p>env是创建的虚拟环境文件夹的名称，如果在执行后，看到如下标志说明已经成功激活了虚拟环境</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/virtualenv.png" alt=""></p><p>脱离虚拟环境也只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="virtualenv-2"><p>暂时没有写，偷懒</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="virtualenv-3"><p>暂时没有写，偷懒</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="torch报错信息的部分解释"><a href="#torch报错信息的部分解释" class="headerlink" title="torch报错信息的部分解释"></a>torch报错信息的部分解释</h2><p>因为某位初学者给出的报错信息如下，就进行一个初步的解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Could not find a version that satisfies the requirement torch&lt;1.6.0,&gt;=1.2.0 (from convlab-2) (from versions: 1.7.0, 1.7.1, 1.8.0, 1.8.1, 1.9.0, 1.9.1, 1.10.0,</span><br><span class="line">1.10.1, 1.10.2)</span><br><span class="line">ERROR: No matching distribution found <span class="keyword">for</span> torch&lt;1.6.0,&gt;=1.2.0</span><br></pre></td></tr></table></figure><p>这个报错信息其实已经非常明确的写明了出错的原因，由于项目指定的pytorch版本为&gt;=1.2.0且&lt;1.6.0，很显然，这位仁兄电脑上肯定是没有的，如果已经安装过其他版本的pytorch重新安装指定版本就会发生版本冲突。</p><h2 id="pip安装指定版本的包"><a href="#pip安装指定版本的包" class="headerlink" title="pip安装指定版本的包"></a>pip安装指定版本的包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;packageName&gt;==&lt;version&gt;</span><br></pre></td></tr></table></figure><p>将尖括号中的参数进行替换即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;因为有人来问关于机器学习python环境的相关问题，就大致写一下&lt;/p&gt;
&lt;h2 id=&quot;python版本介绍&quot;&gt;&lt;a href=&quot;#pyt</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://icimence.cn/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://icimence.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>flutter问题汇总</title>
    <link href="https://icimence.cn/2022/02/06/flutter%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://icimence.cn/2022/02/06/flutter%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-02-06T02:11:52.000Z</published>
    <updated>2022-03-26T14:13:50.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于flutter启动web"><a href="#关于flutter启动web" class="headerlink" title="关于flutter启动web"></a>关于flutter启动web</h2><p>flutter在启动web的debug模式的时候会出现端口的问题，这时候只需要通过启动参数调整启动的端口号即可，代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter -d chrome --web-hostname 127.0.0.1 --web-port 8888</span><br></pre></td></tr></table></figure><p>指定端口之后问题就可以解决了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于flutter启动web&quot;&gt;&lt;a href=&quot;#关于flutter启动web&quot; class=&quot;headerlink&quot; title=&quot;关于flutter启动web&quot;&gt;&lt;/a&gt;关于flutter启动web&lt;/h2&gt;&lt;p&gt;flutter在启动web的debug模式的</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://icimence.cn/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Flutter" scheme="https://icimence.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第32题动归思路</title>
    <link href="https://icimence.cn/2022/01/16/LeetCode%E7%AC%AC32%E9%A2%98%E5%8A%A8%E5%BD%92%E6%80%9D%E8%B7%AF/"/>
    <id>https://icimence.cn/2022/01/16/LeetCode%E7%AC%AC32%E9%A2%98%E5%8A%A8%E5%BD%92%E6%80%9D%E8%B7%AF/</id>
    <published>2022-01-16T09:18:24.000Z</published>
    <updated>2022-03-26T14:13:50.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这是一道LeetCode题目，用来对之前的一篇动态规划的文章进行进一步的实践说明</p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 3 * 104</li><li>s[i] 为 ‘(‘ 或 ‘)’</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-valid-parentheses">https://leetcode-cn.com/problems/longest-valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="动归思路"><a href="#动归思路" class="headerlink" title="动归思路"></a>动归思路</h2><p>首先确定边界问题，负数不能访问，初始值应该为0，f(0)为0。</p><p>然后再思考动态转移公式，发现这道题并不是简单的一个公式就可以解决的，由于括号的匹配一定是由<code>)</code>结束，所以我们只考虑<code>)</code>的情况。总结出一下两种右括号出现的情况</p><ol><li>…….()</li><li>…….))</li></ol><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>第一种情况的状态转移公式比较容易写出，直接给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i) = f(i-2)+2</span><br><span class="line">i&gt;1</span><br></pre></td></tr></table></figure><blockquote><p>在写状态转移公式的过程中我们要对减号比较敏感，当出现减号的时候我们就需要对操作数的大小进行判断，防止越界的发生</p></blockquote><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>第二种情况的状态转移公式就比较难写，首先我们需要知道这个右括号是否在前面有与之对应的左括号，若无，<code>f(i)=0</code>，若有，进行计算。</p><p>那么怎么找到这个右括号对应的括号呢，因为第i-1个右括号记录了最长的有效长度，所以我们可以根据这个长度向前在延伸一位就能找到第i个括号对应的字符，表达出来就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(f(i-dp[i-<span class="number">1</span>] - <span class="number">1</span>) != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">    pass</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里也要注意判断i - dp[i - 1] - 1的正负性</span></span><br></pre></td></tr></table></figure><p>接下来我们要思考的就是如果这个右括号对应了一个左括号要怎么写出这个状态转移公式。我们首先假设将第<code>i-1</code>位的有效长度加入进来写出公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i) = f(i - <span class="number">1</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">//i&gt;1</span></span><br></pre></td></tr></table></figure><p>但是这样的计算结果显然是错误的，因为我们遗漏了匹配到的左括号之前可能是有效的括号字符串，现在这个左括号被成功匹配之后两个有效字符串的长度应该进行相加，所以我们进一步得出正确的有效字符串长度公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(i) = f(i - <span class="number">1</span>) + <span class="number">2</span> + f(i - dp[i - <span class="number">1</span>] - <span class="number">2</span>)</span><br><span class="line"><span class="comment">//这里的i - dp[i - 1] - 2可以理解为i - dp[i - 1] - 1 - 1即匹配到的左括号的再左边一位</span></span><br><span class="line"><span class="comment">//同时需要注意正负性的判断</span></span><br></pre></td></tr></table></figure><p>这样我们就得到了一个完整的状态转移方程，最后只需要取动归数组中最大的值就是本题的答案，题目的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = Math.max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;这是一道LeetCode题目，用来对之前的一篇动态规划的文章进行进一步的实践说明&lt;/p&gt;
&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://icimence.cn/tags/LeetCode/"/>
    
    <category term="Dynamic Programming" scheme="https://icimence.cn/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>动态规划学习笔记</title>
    <link href="https://icimence.cn/2022/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://icimence.cn/2022/01/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-16T03:30:23.000Z</published>
    <updated>2022-03-26T14:13:50.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>其实在一定的条件下贪心算法就可以解决问题，比如凑钱到指定面额的问题。以最熟悉的人民币作为背景，如何用（1，5，10，20，50，100）五种面额的钱币凑出指定数额的钱同时钱数量要尽可能的少，这是我们只需要贪心算法就能解决问题。但是如果有一个很奇怪的国家的发行货币是1，5，11，并且你需要找出面值15的组合，这样贪心算法给出的答案是<code>11+1+1+1+1</code>而我们很轻易的就能发现只要<code>5+5+5</code>就能解决问题。这是因为贪心算法只考虑了眼前最优的情况，并没有给出全局最优解。</p><h2 id="递归的问题及改进思路"><a href="#递归的问题及改进思路" class="headerlink" title="递归的问题及改进思路"></a>递归的问题及改进思路</h2><p>在这个问题中不难发现，可以问题分解。如最后需要15那么如果最后一枚拿的是11就需要凑4，如果最后一枚拿的是5就需要凑10，如果最后一枚拿的是1就需要凑14，文字表述可能有点绕，公式如下（f（x）表示凑x需要多少枚钱币）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = min&#123;f(x-1),f(x-5),f(x-11)&#125; + 1</span><br></pre></td></tr></table></figure><p>从这个公式中其实已经能看到递归的影子，再接下来分析一步将会非常清晰，如求<code>f(x-1)</code>可以参照公式写出下一步的计算公式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x-1) = min&#123;f(x-1-1),f(x-1-5),f(x-1-11)&#125; + 1</span><br></pre></td></tr></table></figure><p>以此类推即可</p><p>所以我们其实是可以使用递归解决这个问题的，下面给出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">1</span>)</span><br><span class="line">        min = Math.min(solve(num - <span class="number">1</span>) + <span class="number">1</span>, min);</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">5</span>)</span><br><span class="line">        min = Math.min(solve(num - <span class="number">5</span>) + <span class="number">1</span>, min);</span><br><span class="line">    <span class="keyword">if</span> (num &gt;=<span class="number">11</span>)</span><br><span class="line">        min = Math.min(solve(num - <span class="number">11</span>) + <span class="number">1</span>, min);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归代码理论上是没有问题的，计算15可以得到正确的答案，但是当输入的数字比较大时耗时长是小事，会大量占用内存是不能接受的。因为递归算法是指数级增长的，所以我们还是需要提出一个新的思路来解决这个问题。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TBA((&quot;f(70)&quot;))--&gt;B((&quot;f(69)&quot;))A--&gt;C((&quot;f(65)&quot;))A--&gt;D((&quot;f(59)&quot;))B--&gt;E((&quot;f(68)&quot;))B--&gt;F((&quot;f(64)&quot;))B--&gt;G((&quot;f(58)&quot;))C--&gt;H((&quot;f(64)&quot;))C--&gt;I((&quot;f(60)&quot;))C--&gt;J((&quot;f(54)&quot;))D--&gt;K((&quot;f(58)&quot;))D--&gt;L((&quot;f(54)&quot;))D--&gt;M((&quot;f(48)&quot;))  </pre></div><p>在这张递推图中我们已经可以看出递推的问题出现在哪里了，下面省略了非常多的计算步骤，但是我们可以看到仅仅在第三层就已经出现了重复计算，计算机不会使用已经计算的结果而是会重新计算一边，导致递推的耗时非常长。</p><p>这里我们可以使用备忘录的方式进行解决，也就是通过创建一个map来记录各个值的计算结果来避免进行重复计算。带有备忘录的递归方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeChange</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验是否已经在备忘录中存在结果,如果存在返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (cache.get(amount) != <span class="keyword">null</span>) <span class="keyword">return</span> cache.get(amount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            min = Math.min(makeChange(amount - <span class="number">1</span>) + <span class="number">1</span>, min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            min = Math.min(makeChange(amount - <span class="number">5</span>) + <span class="number">1</span>, min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (amount &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">            min = Math.min(makeChange(amount - <span class="number">11</span>) + <span class="number">1</span>, min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache.put(amount, min);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实带有备忘录的递归算法的时间复杂度已经相当低了，在这个问题中已经达到了O(n)。所以为什么我们仍然要使用动态规划算法来解决这个问题呢？</p><p>最主要的原因就是内存爆炸(StackOverFlowError)。</p><blockquote><p>反正我的电脑是撑不住<code>f(27000)</code>的备忘录递归，有兴趣的可以自己试试自己电脑的极限在哪里:eyes:</p></blockquote><p>很容易看出我们在递归算法中是使用了自顶向下的一种计算思路，所以形成了一棵树，为了节省内存空间我们需要一种自底向上的计算方法来解决这个问题。这种思路的核心思想就是使用迭代来取代递归。</p><h2 id="动态转移方程"><a href="#动态转移方程" class="headerlink" title="动态转移方程"></a>动态转移方程</h2><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/dp1.png" alt="备忘录表"></p><p>我们将之前的备忘录中的数据化成一张表格</p><blockquote><p>上图中的<code>f[n]</code>代表凑够n最少需要多少钱币的函数，方块内的数字代表函数的结果</p></blockquote><p>我们通过观察上图中的表格，结合之前给出的公式得到<code>f[1] = min(f[0], f[-5], f[-11]) + 1</code></p><p>对于<code>f[-n]</code>的情况我们视为无穷大，就可以通过<code>f[0]</code>得到<code>f[1]=1</code></p><p>再看看<code>f[5]</code>: <code>f[1] = min(f[4], f[0], f[-6]) + 1</code>,这实际是在求<code>f[4] = 4</code>、<code>f[0] = 0</code>、<code>f[-6]=Infinity</code>中最小的值即0，最后加上1，即1，那么<code>f[5] = 1</code>。</p><p>所以其实任何一个节点都是可以通过之前的节点结果计算出来的，而公式又恰好是我们之前给出的递推公式，在这里被称作是动态转移方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n] = min(f[n-1], f[n-5], f[n-11]) + 1</span><br></pre></td></tr></table></figure><p>这里引出了DP的另一个优势，就是更加节省空间，如我们需要求<code>f(70)</code>那么我们只需要知道 <code>f(59)</code> <code>f(69)</code> <code>f(65)</code> 的值就可以了，其他值是可以直接丢弃的，而备忘录不行。其实当这个动态转移方程出现时我们的题目基本上已经做完了。</p><p>但是需要注意的是动态规划问题解题中非常重要的一点就是要确定边界问题，还是硬币找零问题，我们可以确定如果x是负数那么直接视为无穷大，而<code>f(0)</code>应该被赋值为0。</p><h2 id="硬币找零问题完整解答"><a href="#硬币找零问题完整解答" class="headerlink" title="硬币找零问题完整解答"></a>硬币找零问题完整解答</h2><p>题目会给出所有硬币的面额coins数组和一个总金额数amount，我们首先列出完整的动态转移方程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[0] = 0 (n=0)</span><br><span class="line">f[n] = min(f(n-coins[i]) + 1 (n&gt;0)</span><br></pre></td></tr></table></figure><p>根据这个动态转移方程我们不难得出正确的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录,用amount+1填满备忘录,amount+1 表示该值不可以用硬币凑出来</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置初始条件为 0</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                <span class="comment">// 根据动态转移方程求出最小值</span></span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i) &#123;</span><br><span class="line">                    dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 `dp[amount] === amount+1`说明没有最优解返回-1,否则返回最优解</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == amount+<span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中需要注意的是初始化备忘录的时候不能使用可能会误导计算过程的数值如-1这种，只能使用不可能成为最终答案的数值进行初始化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文的写作过程中大量参考了作者<code>寻找海蓝96</code>，他的文章链接：<a href="https://juejin.cn/post/6844904113889624077">https://juejin.cn/post/6844904113889624077</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;其实在一定的条件下贪心算法就可以解决问题，比如凑钱到指定面额的问题。以最熟悉的人民币作为背景，如何用（1，5，10，20，50，100）五种</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://icimence.cn/tags/LeetCode/"/>
    
    <category term="Dynamic Programming" scheme="https://icimence.cn/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>关于leetCode第34题引发的二分查找的思考</title>
    <link href="https://icimence.cn/2022/01/14/%E5%85%B3%E4%BA%8EleetCode%E7%AC%AC34%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://icimence.cn/2022/01/14/%E5%85%B3%E4%BA%8EleetCode%E7%AC%AC34%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2022-01-14T10:57:17.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><ul><li>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</li></ul><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在这个题目中比较明显的就是需要使用二分查找法来进行算法的简化，但是二分查找法一般用来查找某个指定的数字，而在这个题目中，需要查找比指定数字大的和小的数字。</p><p>首先在解题过程中写出的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">var</span> output = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> target == nums[<span class="number">0</span>] ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">        output[<span class="number">0</span>] = mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[mid - <span class="number">1</span>] == target)</span><br><span class="line">       output[<span class="number">1</span>] = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个版本的代码下很容易发现进行的二分查找虽然能够正确的找到下限，但是当输入如下时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2,2]</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>并不能得到理想的输出，检查代码后发现，由于是使用二分查找法，如果整个序列没有比查找数字更大的数是上线的返回一定是错误的，因为二分查找无法返回越界的下标，所以我对这个函数进行了一定的优化。核心思想是判断在计算上限时所需要的-1的动作是否会导致答案错误，改动之后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> target == nums[<span class="number">0</span>] ? <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125; : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output[<span class="number">0</span>] = mid;</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = len - <span class="number">1</span>;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] == target || mid == <span class="number">0</span>) &#123;</span><br><span class="line">            output[<span class="number">1</span>] = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output[<span class="number">1</span>] = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[output[<span class="number">0</span>]] == target &amp;&amp; nums[output[<span class="number">1</span>]] == target ? output : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然已经解决了上述的问题，但是经过运行发现还是错误的，复查后发现因为普通的二分法的弱mid下标直接指向target相同的数字，那么将会直接返回，否则更改上下限下标直接舍去mid下标以避免死循环的出现。但是在这个题目中，需要考虑是否舍去的就恰好是需要查找的数。所以不能在循环体执行结束之后对mid值进行记录而需要在循环过程中对返回的下标做不断的更新，最终能够得到答案。</p><p>在这个思路上，我们对代码进行了整体的重构，在上文的代码中读者应该注意到了while循环体中的内容大致相同，所以我们将两个循环体进行抽象，提取出一个函数，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = binarySearch(nums, target, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightIdx = binarySearch(nums, target, <span class="keyword">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">boolean</span> lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是while循环体中的一个条件判断对mid下标的存储。刚开始可能会有疑问，为何对mid下标的更新仅发生在这个指定的条件下而另一个分支则不对mid进行更新。这里需要注意的是只有满足在if中的条件的语句的条件下计算出的mid才是有效的，在另一个分支中计算出的mid一定是无效数据，是错误的，所以不需要进行记录。</p><p>同时可以看到在主方法体中，对最后的两个下标进行了验算，针对target不存在的情况进行了排除，最终就可以得到正确的答案。</p><h2 id="续"><a href="#续" class="headerlink" title="续"></a>续</h2><p>在这种思路中通过ans对二分查找的过程变量进行存储。最后进行输出，我个人认为这种方法在一定程度上更加难理解，可以使用二分查找的排除法进行进一步的改写，让代码更符合逻辑思维。</p><h2 id="排除思想"><a href="#排除思想" class="headerlink" title="排除思想"></a>排除思想</h2><p>首先需要改写的就是循环条件在上述条件中<code>ans</code>的作用就是对计算过程中的<code>ans</code>进行迭代的存储，而为了避免对<code>ans</code>的取值情况的思考，可以改变循环体的条件为<code>while(left&lt;right)</code>这个循环体在推出循环时满足条件<code>left=right</code>所以仅需要返回任意一个值即可。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>循环体的条件为<code>while(left&lt;right)</code></li><li>写if-else语句的时候对排除情况进行思考（下文会有详细的说明）</li><li>对边界收缩行为进行思考（下文会有详细说明）</li><li>退出循环之后考虑是否要对返回值进行校验</li></ol><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先解释一下最容易解释的第四点，由于排除法只是排除了所有不可能的选项，所以如果在这个有序数组中原本就不存在<code>target</code>排除法依然会返回一个下标，这时候就需要对这个下标进行检验，如果题目已经确保这个数组中存在需要寻找的元素则不需要进行二次检验。</p><h3 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h3><h4 id="1-在有序数组中查找等于目标元素的第一个索引"><a href="#1-在有序数组中查找等于目标元素的第一个索引" class="headerlink" title="1. 在有序数组中查找等于目标元素的第一个索引"></a>1. 在有序数组中查找等于目标元素的第一个索引</h4><p>在这种情况下首先给出正确的代码，读者可以直接跳过代码阅读解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) +left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到先对左右指针的取值进行定义，在这种情况下右指针指向最后一个数字即可。顺带一笔，这里的mid的求解方法可以防止int越界的发生，在二分查找中推荐使用这种算法来求中值。接下来就是条件的判断如果<code>nums[mid]&lt;target</code>那么我们可以肯定的是我们最终要求的下标一定在<code>mid</code>下标的右侧，所以我们将左指针进行右移，同时我们考虑到我们要求的是第一个索引，所以我们可以将<code>mid</code>下标直接排除。而对于<code>nums[mid]&gt;=target</code>的情况我们可以确定最终要求的下标在<code>mid</code>的左侧，但是并不知道<code>mid</code>是否就是我们需要寻找的下标即不能排除mid，所以将<code>right=mid</code>。</p><p>在这里需要提一下，可能会有人有疑问，为什么判断条件不能是<code>nums[mid]&lt;=target</code>，我们寻找的是目标元素的第一个索引，在排除法的思想中，若<code>nums[mid]&lt;target</code>我们可以确定<code>mid</code>及<code>mid</code>的左侧不会出现目标元素的第一个索引，但是如果<code>nums[mid]=target</code>我们会发现是目标元素的第一个索引不可能出现在<code>mid</code>的右侧，这两个条件实际上是冲突的，所以我们将等于的情况与大于合并而不是与小于合并。</p><h4 id="2-在有序数组中查找等于目标元素的最后一个索引"><a href="#2-在有序数组中查找等于目标元素的最后一个索引" class="headerlink" title="2. 在有序数组中查找等于目标元素的最后一个索引"></a>2. 在有序数组中查找等于目标元素的最后一个索引</h4><p>这个情况其实通过以上的分析已经相当容易理解了，我直接给出代码和注释，希望读者能够自行理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) +left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) <span class="comment">//在这种情况下能确定需要求的下标在mid的左侧</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//要求的下标在mid及mid的右侧</span></span><br><span class="line">            left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-在有序数组中查找第一个大于目标元素的下标"><a href="#3-在有序数组中查找第一个大于目标元素的下标" class="headerlink" title="3. 在有序数组中查找第一个大于目标元素的下标"></a>3. 在有序数组中查找第一个大于目标元素的下标</h4><p>主要就是对判断条件的分析，当<code>nums[mid]&gt;target</code>时需要寻找的下标一定在<code>mid</code>及<code>mid</code>的左侧，而等于和小于则在mid的右侧，下面直接给出代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstLarger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-在有序数组中查找第一个小于目标元素的下标"><a href="#4-在有序数组中查找第一个小于目标元素的下标" class="headerlink" title="4.  在有序数组中查找第一个小于目标元素的下标"></a>4.  在有序数组中查找第一个小于目标元素的下标</h4><p>同理，直接给代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findFirstLarger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((right - left + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况和第二种情况中需要注意的就是在<code>right = mid - 1;</code>的情况下，可能会出现死循环的情况，所以在<code>mid</code>计算的时候需要注意使用<code>(left+right+1)/2</code>就可以避免死循环情况的出现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h2&gt;&lt;p&gt;给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;如果数组中</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="LeetCode" scheme="https://icimence.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>面向服务复习提纲</title>
    <link href="https://icimence.cn/2021/04/26/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
    <id>https://icimence.cn/2021/04/26/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</id>
    <published>2021-04-26T11:45:38.000Z</published>
    <updated>2022-03-26T14:13:50.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些概念："><a href="#一些概念：" class="headerlink" title="一些概念："></a>一些概念：</h2><ol><li>Web服务是实现SOA的核心技术，但SOA并不等同于Web服务。Web服务是一套技术体系，可以用来构建应用解决方案，解决特定的消息通信和应用集成问题。而SOA 是一种软件架构，不局限于某种技术组合（如Web服务），它超越技术范畴，甚至可以用来组织公司。</li><li>企业服务总线（ESB）是SOA基础架构（basic frastruct）的关键组件，是一种消息代理架构，管理消息通信、服务交互等等。</li><li>WSDL：Web服务描述语言，基于XML，但它才是Web服务的核心。因为它描述Web 服务提供的操作（服务能力）以及这些操作接收和返回的参数。WSDL包含的信息： 服务做什么，应该如何使用它们，它们在哪里。也就是说提供者和调用者都需要参考WSDL，从这个意义上来说WSDL是核心。</li></ol><h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="一、为何需要构建服务生态系统？什么是服务生态系统中的垂直服务和水平服务？它们有何联系和区别？试举例加以说明"><a href="#一、为何需要构建服务生态系统？什么是服务生态系统中的垂直服务和水平服务？它们有何联系和区别？试举例加以说明" class="headerlink" title="一、为何需要构建服务生态系统？什么是服务生态系统中的垂直服务和水平服务？它们有何联系和区别？试举例加以说明"></a>一、为何需要构建服务生态系统？什么是服务生态系统中的垂直服务和水平服务？它们有何联系和区别？试举例加以说明</h3><ol><li><strong>服务生态系统（参考商业生态系统的答案）</strong></li></ol><p>一方面：面向服务的快速发展导致单个组织无法独立提供全套服务，提供的有限服务也无法被广泛运用；已存在的服务并不能很好的被发现和调用，也导致了大量冗余服务</p><p>另一方面：原先的服务系统是复杂、脆弱、特殊的，从上层业务看，无法灵活应对实际业务的变更；从底层实现看，也无法及时应对底层技术的更新、或者新增的功能 因此构建服务生态系统，运用面向服务的分析和设计原则，使得产生的服务具有良好的可发现性和可复用性，同时能灵活应对业务领域和技术领域的变更。</p><ol><li>垂直服务</li></ol><ul><li><p>单独面向一个客户，提供系列功能的服务</p></li><li><p>从消费者的角度说，垂直服务可以被同时、独立地使用，分为纯IT服务和IT-enabled 服务</p></li></ul><ol><li>水平服务</li></ol><ul><li><p>用于构建垂直服务、可重用的、跨行业的公共服务</p></li><li><p>分为公共业务服务和IT服务</p></li></ul><ol><li>联系与区别</li></ol><ul><li><p>垂直服务和水平服务都是通过服务系统来实现业务服务</p></li><li><p>水平服务是功能相关的，简单且相对稳定，一般由IT专家开发</p></li><li><p>垂直服务是流程相关的，复杂且易变更，需要领域专家参与开发</p></li><li><p>垂直服务实际上是一系列水平服务的封装，将上下文无关的水平服务根据特定的业务流程进行编排，最后打包为一个解决特定问题的垂直服务</p></li></ul><p>举例：</p><p>学校的借书服务、打印成绩单服务是垂直服务，都需要进行身份认证，身份认证就是一个水平服务；借书服务和打印成绩单服务除了身份认证还包含其他的服务，就是将简单的水平服务构建成能实现业务目标或流程的垂直服务</p><h3 id="二、试描述SOA三角操作模型，并对比传统的端到端服务调用模式，阐述其IT优势和商业优势"><a href="#二、试描述SOA三角操作模型，并对比传统的端到端服务调用模式，阐述其IT优势和商业优势" class="headerlink" title="二、试描述SOA三角操作模型，并对比传统的端到端服务调用模式，阐述其IT优势和商业优势"></a>二、试描述SOA三角操作模型，并对比传统的端到端服务调用模式，阐述其IT优势和商业优势</h3><h4 id="SOA三角操作模型"><a href="#SOA三角操作模型" class="headerlink" title="SOA三角操作模型"></a>SOA三角操作模型</h4><p>   <img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/soa.png" alt="soa示例"></p><ol><li>三种角色：</li></ol><ul><li><p>服务提供者：发布自己的服务，并且对服务请求进行响应</p></li><li><p>服务请求者：利用服务注册查找所需要的服务，然后使用该服务</p></li><li><p>服务注册：注册已经发布的服务，对其进行分类，并提供搜索服务</p></li></ul><ol><li>三个操作：</li></ol><ul><li><p>发布：为了使服务可访问，需要发布服务描述以使服务使用者可以发现它</p></li><li><p>查找：服务请求者查询服务注册来找到满足其标准的服务</p></li><li><p>绑定：检索到服务描述后，服务使用者继续根据服务描述中的信息调用服务</p></li></ul><p>对比传统端到端服务调用模式：</p><p>降低服务调用者和服务提供者之间的耦合；调用者只需要向服务注册请求调用，服务注册会在满足条件的服务提供方中选一个交给调用者，调用者不需要担心提供者是否会停止服务；提供者需要变更自己的服务时，服务注册就换一个实现给调用者。</p><h4 id="IT优势"><a href="#IT优势" class="headerlink" title="IT优势"></a>IT优势</h4><ol><li><p>松耦合，消除假依赖———复用</p><ul><li>语言、平台和厂商中立</li><li>消除时间依赖</li><li>消除访问地址依赖</li><li>消除访问协议依赖 </li></ul></li><li>服务间接寻址 ——— 灵活</li><li><p>商业优势</p><ul><li>保护企业投资，提升现有IT资源的作用，促进IT资源的复用</li><li>提高企业灵敏度</li><li>支持企业外包管理模式</li></ul></li></ol><h3 id="三、XML的结构（树状结构）？与原先的文本-json-二进制相比有什么好处？"><a href="#三、XML的结构（树状结构）？与原先的文本-json-二进制相比有什么好处？" class="headerlink" title="三、XML的结构（树状结构）？与原先的文本/json/二进制相比有什么好处？"></a>三、XML的结构（树状结构）？与原先的文本/json/二进制相比有什么好处？</h3><p>XML形成的是树状结构，一个XML文档有唯一的element作为根元素，该元素是所有其他元素的父元素，同时所有的元素均可拥有子元素。</p><p>优点：XML文档的内容和结构完全分离，基于这个特性可以实现服务的功能管理和流程管理彻底分离；</p><blockquote><p>互操作性强，纯文本文件可以方便地在不同的系统之间通信； 规范统一，XML有统一的标准语法，可以跨平台、跨系统</p><p>可扩展性强，可以根据XML的基本语法，进一步限定在特殊环境下，使用的</p></blockquote><p>XML文档格式</p><blockquote><p>支持多种编码，XML包含所使用的编码，方便多语言系统对数据进行处理</p></blockquote><h3 id="四、试描述soap包的结构，并结合该结构，阐述soap处理模型（无需准确给出相关命名空间和元素名称）"><a href="#四、试描述soap包的结构，并结合该结构，阐述soap处理模型（无需准确给出相关命名空间和元素名称）" class="headerlink" title="四、试描述soap包的结构，并结合该结构，阐述soap处理模型（无需准确给出相关命名空间和元素名称）"></a>四、试描述soap包的结构，并结合该结构，阐述soap处理模型（无需准确给出相关命名空间和元素名称）</h3><h4 id="soap包结构"><a href="#soap包结构" class="headerlink" title="soap包结构"></a>soap包结构</h4><p>soap包本质是一个xml文档，包含下列元素：</p><ol><li><p>Envelope元素</p><blockquote><ul><li>必需元素，根元素，标识此XML文档为一条 SOAP 消息</li><li>可以包含命名空间和声明额外的属性。如果出现额外属性，则必须使用命名空间修饰</li></ul></blockquote></li><li><p>Header 元素</p><blockquote><ul><li>可选元素，有关 SOAP 消息的应用程序专用信息（比如认证、支付等）</li></ul></blockquote></li><li><p>Body 元素</p><blockquote><ul><li>必需元素，包含所有的调用和响应信息</li></ul></blockquote></li><li><p>Fault 元素</p><blockquote><ul><li>可选元素，提供有关在处理此消息所发生错误的信息</li></ul></blockquote></li></ol><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/soap.png" alt="soap示例"></p><h4 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h4><ol><li><p>用XML打包请求</p><blockquote><ul><li>将接口名作为根节点</li><li>方法和参数作为结点</li></ul></blockquote></li><li><p>将请求发给服务器</p><blockquote><ul><li>不创建自己的TCP/IP信息，利用HTTP</li><li>将 请 求 封 装 成 HTTP POST 请 求 格 式 发 出</li></ul></blockquote></li><li><p>服务器接收到请求，解码XML，处理请求，以XML格式返回响应</p><blockquote><ul><li>与请求比较，方法的结点名字变为请求的方法名后缀Response</li><li>客户程序知道自己调用了哪个方法，根据方法名后缀Response寻找调用方法的返回值</li></ul></blockquote></li></ol><h4 id="处理模式"><a href="#处理模式" class="headerlink" title="处理模式"></a>处理模式</h4><ol><li><p>简单模式</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/1.png" alt="简单模式"></p></li><li><p>复杂模式</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/2.png" alt="复杂模式"></p></li></ol><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><ol><li><p>远程过程调用模式</p><blockquote><ul><li>一种同步请求/响应交互的方法</li><li>发出请求后会一直等待响应</li></ul></blockquote></li><li><p>面向文档模式</p><blockquote><ul><li>一种异步交互的方法</li><li>发送一个完整XML文档，然后等待通知，结果会在处理后发送回来</li></ul></blockquote></li></ol><p>补充：SOAP为什么被设计成两块？实际SOAP如何利用这两个信道？</p><p>被设计成header和body两块，一方面分离了控制信息和主要数据，让信息结构更加清晰；另一方面，在复杂模式中，header中的头块信息可以和中间节点进行角色上的转变。</p><p>body是必须的部分，内嵌的XML是完成当前任务的主要数据；而如果是一些附加的、用来协助完成的控制信息，则放在header中</p><h3 id="五、试结合WSDL文件的结构，说明WSDL文档记载了服务的哪些-信息，并阐述为何需要将WSDL文件分为抽象部分和具体部分"><a href="#五、试结合WSDL文件的结构，说明WSDL文档记载了服务的哪些-信息，并阐述为何需要将WSDL文件分为抽象部分和具体部分" class="headerlink" title="五、试结合WSDL文件的结构，说明WSDL文档记载了服务的哪些 信息，并阐述为何需要将WSDL文件分为抽象部分和具体部分"></a>五、试结合WSDL文件的结构，说明WSDL文档记载了服务的哪些 信息，并阐述为何需要将WSDL文件分为抽象部分和具体部分</h3><h4 id="结构（WSDL-2-0）"><a href="#结构（WSDL-2-0）" class="headerlink" title="结构（WSDL 2.0）"></a>结构（WSDL 2.0）</h4><p>以description元素为根结点</p><p>import、include：拼装不同部门/组织定义的文档，形成完整的WSDL语意</p><ol><li><p>抽象部分</p><blockquote><ul><li>Types：使用到的数据结构或者叫数据格式规范，独立于语言和平台</li><li>Interface：operation的集合即服务能力的集合，描述服务能力</li><li>operation：input、output、infault、outfault</li></ul></blockquote></li><li><p>具体部分</p><blockquote><ul><li>Binding：特定端口类型的具体协议和数据格式规范的绑定。</li><li>Service：对服务整体的抽象，包含若干个endpoint endpoint：将绑定与当前地址关联</li></ul></blockquote></li></ol><h4 id="服务的哪些信息"><a href="#服务的哪些信息" class="headerlink" title="服务的哪些信息"></a>服务的哪些信息</h4><p>功能 也叫服务能力，即调用某一个特定的操作，这个操作能被用来完成面向服务的一项功能</p><p>数据结构 通信消息中使用的数据结构</p><p>协议的绑定 即确定消息如何在具体的网络协议上传输总的来说就是服务做什么、如何使用服务以及服务在哪里</p><h4 id="分开原因"><a href="#分开原因" class="headerlink" title="分开原因"></a>分开原因</h4><p>一方面：</p><ul><li><p>抽象部分以独立于平台和语言的方式定义服务的逻辑意义，并不包含任何随机器或语言而变的元素，使不同的服务调用者都能调用实现</p></li><li><p>具体部分则包含了随网站而异的东西，由各实现方依据自己的情况定制</p></li><li><p>在保证可复用的同时又不局限各实现方的个性化定制</p></li></ul><p>另一方面：</p><ul><li>定义服务与实现服务可能是不同的部门或者组织，那么抽象部分与具体部分的WSDL 也应当由各自的部门定义、持有与管理（C9高校做让选课无缝衔接，教育部持有抽象部分，各高校持有具体部分）</li></ul><h3 id="六、以UDDI和WSIL为例，分别阐述集中式和分布式服务发布-查询的过程，并对比这两种方法"><a href="#六、以UDDI和WSIL为例，分别阐述集中式和分布式服务发布-查询的过程，并对比这两种方法" class="headerlink" title="六、以UDDI和WSIL为例，分别阐述集中式和分布式服务发布/查询的过程，并对比这两种方法"></a>六、以UDDI和WSIL为例，分别阐述集中式和分布式服务发布/查询的过程，并对比这两种方法</h3><ol><li><p>集中式发布</p><blockquote><p>S1：软件公司和标准组织向服务注册发布规范,即tModel 。</p><p>S2：公司完成服务的开发，注册关于业务及提供的服务的描述。</p><p>S3：UDDI 服务注册给每个实体指定一个唯一的标识符，从而能时刻了解所有实体的情况。</p></blockquote></li><li><p>集中式查询</p><blockquote><p>查询者使用UDDI提供的API，根据业务信息、服务信息或服务类别等搜索相关的服务</p><p>UDDI找到相应服务的WSDL并生成SOAP发送给查询者，查询者根据WSDL中描述的 接口等信息调用服务</p></blockquote></li><li><p>分布式发布</p><blockquote><p>S1：将服务描述为一个XML文档发布在Web服务器上</p><p>S2：使用WSIL从现有的服务描述文档生成引用</p><p>S3：引用指针连接到下一个服务，既可以是发布在UDDI注册中心的服务，也可以是另一个WSIL，这样不断地连接最终形成了WSIL超链。</p></blockquote></li><li><p>分布式查询</p><blockquote><p>通常使用构建好的查询工具查询；遍历WSIL超链，进行查找</p><p>S1：确定起始WSIL的位置</p><p>S2： 执 行 查 找 </p><p>S3：显示该WSIL中的链接表</p><p>S4：选择一个链接打开，如果打开的WSIL还包含其他链接，则继续追踪</p><p>S5：重复步骤3和4，直到找到目标信息</p></blockquote></li><li><p>对比</p><blockquote><p>主要区别是代价和复杂性</p><p>UDDI：适用于希望得到最大复用、得到最大访问范围的服务；</p><p>UDDI使用黄页机制，维护大量服务，代价大，但好处是分门别类，便于管理和共享 </p><p>WSIL：适用于当前提供服务的企业事先已经规划完毕，（我把它写成了一个目录，这个目录挂载在某个网站，让别人可以直接下载）根据超链的方式，对外提供这个企业内部所有分门别类的服务；复用性稍差，好处是不需要付出额外的代价</p></blockquote></li></ol><h3 id="七、试对比面向服务泛型和面向对象泛型（提示：方法论、抽象和协作层次、代码共享和复用、动态绑定和重新组合、重组、组件通讯和接口，系统维护、可靠性、软件拥有）"><a href="#七、试对比面向服务泛型和面向对象泛型（提示：方法论、抽象和协作层次、代码共享和复用、动态绑定和重新组合、重组、组件通讯和接口，系统维护、可靠性、软件拥有）" class="headerlink" title="七、试对比面向服务泛型和面向对象泛型（提示：方法论、抽象和协作层次、代码共享和复用、动态绑定和重新组合、重组、组件通讯和接口，系统维护、可靠性、软件拥有）"></a>七、试对比面向服务泛型和面向对象泛型（提示：方法论、抽象和协作层次、代码共享和复用、动态绑定和重新组合、重组、组件通讯和接口，系统维护、可靠性、软件拥有）</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/3.png" alt="图"></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/4.png" alt="图"></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/5.png" alt="图"></p><h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><h3 id="一、试结合相关协议和框架，描述一个web-service从创建开始到被最终服务消费者调用的全过程中对服务的建模、查询和调用的全过程"><a href="#一、试结合相关协议和框架，描述一个web-service从创建开始到被最终服务消费者调用的全过程中对服务的建模、查询和调用的全过程" class="headerlink" title="一、试结合相关协议和框架，描述一个web service从创建开始到被最终服务消费者调用的全过程中对服务的建模、查询和调用的全过程"></a>一、试结合相关协议和框架，描述一个web service从创建开始到被最终服务消费者调用的全过程中对服务的建模、查询和调用的全过程</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/6.png" alt="图"></p><ol><li>服务的建模</li></ol><p><strong>XML(Namespace、XML Schema)、SOAP、WSDL</strong></p><p>&emsp;&emsp;XML定义了Web服务中的消息交换格式，使用XML Schema定义不同的数据结构， 引入Namespace使得XML、XML Schema中的元素和属性全球唯一且全球共享；</p><p>&emsp;&emsp;SOAP提供了一种标准的方法，使得运行在不同平台、使用不同的技术和编程语言的应用程序可以互相进行通信，服务的发布、查找、调用，都通过SOAP传递XML消息</p><p>&emsp;&emsp;WSDL对服务能力、服务中使用的数据结构以及传输绑定给出定义和描述；提供了一种基于XML的标准接口定义语言/服务能力定义语言，用以在服务的提供者/调用者/服务注册之间，交换必要的有关Web Service的信息</p><p>&emsp;&emsp;对于大多数服务，用以上三个协议和框架可以完成建模；对于一些更为复杂的服务，如复合服务或者是带有非功能性需求的服务，还需要用到其他协议和框架完成建模。BPEL定义多个服务间如何交互和合作，从而将一组现有的服务根据业务流程构建起来，实现业务服务。WS-Policy可以实现一非功能性需求，如信息加密，权限验证等。</p><p>&emsp;&emsp;建模完成后，服务提供者通过UDDI或者WSIL将服务发布出去。其中，UDDI利用分页机制，让服务得到最大可能的复用和共享范围；WSIL使用树形连接结构，适用于企业既定的服务。</p><ol><li>服务的查询</li></ol><p>&emsp;&emsp;消费者程序发送SOAP消息给服务注册，描述自己需要的服务；服务注册查询注册 表，通过WSDL服务合约找到一系列符合条件的服务；服务注册将查询到的WSDL通过SOAP发送给消费者程序，让消费者程序从中选择可用的服务；或者服务注册自动化筛 选出当前最符合消费者程序要求的服务，通知消费者程序。</p><ol><li>服务的调用</li></ol><p>&emsp;&emsp;消费者程序根据WSDL中提供的服务位置进行调用；其中，消费者和提供者基于WSDL中约定的接口进行消息的发送和接收；另一方面，当前服务可能同时被多个消费者程序使用，创建了一系列服务实例，WS-Addressing提供了相应的机制，确保服务消费者能在实例池中找到特定的实例并与之通信。另一方面，由于创建的实例是有状态的，利用WSRF对状态数据进行存取，进行状态管理，提高资源利用率。</p><h3 id="二、以电信企业为应用背景，举例描述服务分析和服务设计的过程。并结合面向服务的设计原则（标准化服务合约、服务松散耦合、服务抽象、服务可复用性、服务自治、服务无状态性、服务可发现性、服务可组合性），讨论”schema集中化””合约集中化””逻辑集中化”-在设计过程中的应用。"><a href="#二、以电信企业为应用背景，举例描述服务分析和服务设计的过程。并结合面向服务的设计原则（标准化服务合约、服务松散耦合、服务抽象、服务可复用性、服务自治、服务无状态性、服务可发现性、服务可组合性），讨论”schema集中化””合约集中化””逻辑集中化”-在设计过程中的应用。" class="headerlink" title="二、以电信企业为应用背景，举例描述服务分析和服务设计的过程。并结合面向服务的设计原则（标准化服务合约、服务松散耦合、服务抽象、服务可复用性、服务自治、服务无状态性、服务可发现性、服务可组合性），讨论”schema集中化””合约集中化””逻辑集中化” 在设计过程中的应用。"></a>二、以电信企业为应用背景，举例描述服务分析和服务设计的过程。并结合面向服务的设计原则（标准化服务合约、服务松散耦合、服务抽象、服务可复用性、服务自治、服务无状态性、服务可发现性、服务可组合性），讨论”schema集中化””合约集中化””逻辑集中化” 在设计过程中的应用。</h3><p>举例：电信企业有订购、退订套餐，账单结算等基本业务流程</p><h4 id="1-服务分析流程"><a href="#1-服务分析流程" class="headerlink" title="1.服务分析流程"></a>1.服务分析流程</h4><p>面向服务分析的目标是讨论需要构建哪些服务，每个服务应该封装哪些逻辑。分析的核心是业务服务。</p><ol><li><p>进行文档化的需求描述，<strong>定义流程自动化需求</strong>，作为服务候选建模的依据；由于电信企业发展比较完善，可以直接使用之前的需求文档分析；</p></li><li><p>对<strong>现有的自动化系统进行分析、识别</strong>；分析企业正在使用的系统具有的功能；</p></li><li><p>对<strong>服务候选建模</strong>，识别服务操作候选，并将其分组。</p></li></ol><p>在面向服务分析流程中，需要考虑服务可复用性、服务自治和服务可发现性；</p><p>可复用性：在服务建模中，需要：精化已有的服务能力候选，使其更加一般化和可复用；定义额外的服务能力候选，这些能力是在构成服务建模过程的基础的业务流程自动化所需之外的</p><p>自治：对已有自动化系统收集得到的信息，会影响服务系统所能达到的自治级别；比如根据信息决定保留遗留系统，那么达到共享自治，独立开发的可能达到逻辑自治或完全自治</p><p>可发现性：从服务生命周期开始，尤其是在产生服务操作候选时，需要以统一的方式， 记录所有元数据；在服务建模过程中，业务和技术专家需要一起合作，建立服务候选</p><h4 id="2-服务设计流程"><a href="#2-服务设计流程" class="headerlink" title="2.服务设计流程"></a>2.服务设计流程</h4><p>服务设计过程，是从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中。</p><ol><li><p>组合SOA：选择编排、业务、应用服务层中的哪些进行实现，定义核心的SOA标 准，选择SOA扩展（WS-*协议）</p></li><li><p>根据业务层级，分别设计以实体为核心的业务服务，应用服务，以任务为核心的业务服务</p></li><li><p>设计面向服务业务过程，组合服务构建出业务流程</p></li></ol><h5 id="“schema集中化”："><a href="#“schema集中化”：" class="headerlink" title="“schema集中化”："></a>“schema集中化”：</h5><p>&emsp;&emsp;传统的做法是在订购服务、退订服务中使用不同的套餐数据结构，而按照标准化服务合约，所有使用的数据结构都应该被单独定义、管理，与具体的操作流程无关。</p><p>&emsp;&emsp;采用Schema集中化的设计模式，将电信企业划分为多个分离的领域（部门），每个领域都可以被独立地进行标准化和治理，每个领域定义和管理自己的schema，作为整个服务系统的基本数据结构；在不同的服务中，使用这些schema，避免了频繁且不必要的数据转换；在必要的情况下，可以利用这些schema定义新的数据结构</p><h5 id="“合约集中化”"><a href="#“合约集中化”" class="headerlink" title="“合约集中化”"></a>“合约集中化”</h5><p>为了保证服务松散耦合，避免消极耦合，采用合约集中化，将对服务的访问严格控制在合约内：</p><ol><li><p>所有的合约应该被集中管理，拥有一致的设计原则和设计目标；</p></li><li><p>在服务生态系统中，任何情况都不可以绕开合约去访问具体内容</p></li></ol><p>服务抽象&amp;服务可发现性设计服务暴露的信息</p><p>服务抽象：技术信息、功能、程序逻辑、服务质量抽象</p><p>服务抽象出来并对外界可用的信息就是服务合约，服务合约的设计标准会影响到其他</p><h5 id="“逻辑集中化”"><a href="#“逻辑集中化”" class="headerlink" title="“逻辑集中化”"></a>“逻辑集中化”</h5><p>为了实现服务可复用性，让消费者程序只调用指定的服务，要建立服务库存，在规范的服务库存中，每个服务代表来一个独特的功能域，这就要求服务边界之间没有重叠。</p><p>设置专家管理服务库存，应用开发人员不能直接往服务库存中增改需要的服务，只能请求当前服务库存管理人员进行审查，作出恰当的决策。</p><p>同时，服务可发现性是实现服务可复用的前提，服务自治是可复用服务潜在高性能和并行使用的保证；无状态性能提高服务的可用性</p><h5 id="逻辑集中化和合约集中化"><a href="#逻辑集中化和合约集中化" class="headerlink" title="逻辑集中化和合约集中化"></a>逻辑集中化和合约集中化</h5><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/7.png" alt=""></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/8.png" alt=""></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/9.png" alt=""></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/soa/10.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些概念：&quot;&gt;&lt;a href=&quot;#一些概念：&quot; class=&quot;headerlink&quot; title=&quot;一些概念：&quot;&gt;&lt;/a&gt;一些概念：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Web服务是实现SOA的核心技术，但SOA并不等同于Web服务。Web服务是一套技术体系，可以用来构建应</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="面向服务" scheme="https://icimence.cn/tags/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库复习提纲</title>
    <link href="https://icimence.cn/2021/04/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
    <id>https://icimence.cn/2021/04/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</id>
    <published>2021-04-22T08:35:56.000Z</published>
    <updated>2022-03-26T14:13:50.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本复习提纲由Dart完成整理。</p><p>内容没有按题号来，主要按6+上课复习涉及到的知识点</p><h3 id="1-B-树索引"><a href="#1-B-树索引" class="headerlink" title="1. B+树索引"></a>1. B+树索引</h3><h4 id="1-1-B-树的结构"><a href="#1-1-B-树的结构" class="headerlink" title="1.1 B+树的结构"></a>1.1 B+树的结构</h4><p>索引结构为树状层次结构，根节点会将数值分成若干区间，每个区间用指针指向下一层节点，下一层节点同样划分成若干区间，指向再下一层节点，依次往下</p><p>最底层的节点——叶节点，叶节点记录索引字段的值和此值所对应的基本表相关的记录存放的地址，将这个地址称为rowid </p><p>读取文件的步骤为：在b树中逐层向下找到rowid（索引的过程），之后根据rowid取读取基本表相关记录内容。读取每层节点的值都是一次io操作，下图中3次io操作是索引，再经历一次io操作查表即可获得基本表相关记录，即4次io</p><p>所有的叶节点都是按顺序在底层横向连接在一起，属于顺序存储的数据结构，对于搜索范围数据非常有用</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/sql/1.jpg" alt="B+"></p><h4 id="1-2-B-树索引能做什么，不能做什么，理由"><a href="#1-2-B-树索引能做什么，不能做什么，理由" class="headerlink" title="1.2 B+树索引能做什么，不能做什么，理由"></a>1.2 B+树索引能做什么，不能做什么，理由</h4><ul><li><p>能做什么</p><p>全键值查询（等值查询），每一次查询都是固定的次数的io操作（基于上图为4），3次索引+1次查表，不会受基本表大小的影响，效率一样</p><p>范围查询，查询过程为：先通过等值查询找到范围最左侧的值对应的块，然后横向读取叶节点，直到读到范围最右侧的值对应的块为止，读完索引以后根据地址（rowid）找值即可。由于数据在叶节点中横向顺序查询，因此范围查询很方便，效率很高</p><p>键前缀查询，与范围查询类似。</p></li><li><p>不能做什么</p><p>后缀查询</p></li></ul><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><h4 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h4><p>索引是否合理取决于它是否有用，判断适用性的依据是检索比例（查询到的结果集在原数据中所占的比例，一般为10%，但是没有明确的分界线）</p><p>查询结果所占的百分比越低，称查询越具有选择性</p><p>越少的数据访问，越有必要通过索引来提升查询效率，如果比例过大，则可能还不如全表遍历</p><p>两种b树索引适用情况：</p><ul><li><p>仅需要访问基本表中很少一部分行可以使用索引</p></li><li><p>访问基本表很多行，只使用索引，不使用表</p><blockquote><p>e.g</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> x,y</span><br><span class="line"><span class="keyword">From</span> T</span><br><span class="line"><span class="keyword">where</span> x</span><br></pre></td></tr></table></figure><p>即所需查询的数据中，select需要筛选的字段只有x,y,则可以通过复合键索引（见2.2），读完整个索引，查询结果可得，不需要查询基本表</p></blockquote></li></ul><h4 id="2-2-复合键索引"><a href="#2-2-复合键索引" class="headerlink" title="2.2 复合键索引"></a>2.2 复合键索引</h4><p>复合键索引，即对多个字段构建的索引</p><blockquote><p>e.g. index(x,y)</p></blockquote><p>复合键索引本质上是按照排名第一的字段进行的索引，如上例中index(x)和index(x,y)本质是一样的，如果有index(x,y)，则不需要index(x)，因为二者组织方式是一样的</p><blockquote><p>e.g. 对x,y进行复合键索引，本质上是对x构建索引一样，唯一的差别是在叶节点增加一列y的值，对每个x的取值，y进行排序</p></blockquote><h4 id="2-3-索引加外键的理由"><a href="#2-3-索引加外键的理由" class="headerlink" title="2.3 索引加外键的理由"></a>2.3 索引加外键的理由</h4><h5 id="对数据库的某些操作有影响："><a href="#对数据库的某些操作有影响：" class="headerlink" title="对数据库的某些操作有影响："></a>对数据库的某些操作有影响：</h5><blockquote><p>e.g.表A student的外键参照了表B department的主键，两张表需要同时修改，stu表很大，而用户只是希望从department表删除一条记录，dbms为了避免表间依赖的不一致性，s tu需要检查stu表中是否包含了de表中待删除的记录，就会花费较多时间，并有可能影响到操作，而有索引之后会节省很多时间</p></blockquote><h5 id="对并发也有影响："><a href="#对并发也有影响：" class="headerlink" title="对并发也有影响："></a>对并发也有影响：</h5><p>外键不加索引有可能会造成死锁，若无，查找子记录的速度就会很慢，参照表被锁住的时间会很长，阻塞更多的操作，两个进程互锁对方需要的参照表就会引发死锁，加外键的必要性在于可以避免枷锁时间过长，进程需要的时间缩短，降低了出现死锁的概率</p><h5 id="什么时候不需要："><a href="#什么时候不需要：" class="headerlink" title="什么时候不需要："></a>什么时候不需要：</h5><p>表b很少被修改，例如表b为字典表，其主键作为表a的外键不需要加索引，因为表b很难产生修改的情况，因而很难产生并发冲突</p><h4 id="2-4-同一字段-多个索引-字段顺序问题"><a href="#2-4-同一字段-多个索引-字段顺序问题" class="headerlink" title="2.4 同一字段 多个索引 字段顺序问题"></a>2.4 同一字段 多个索引 字段顺序问题</h4><p>如果系统为外键自动增加索引，常常会导致同一字段属于多个索引的情况</p><blockquote><p>e.g. 多对多的情况：一个订单包含多个商品，一个商品也在多个订单中出现，因此需要在中间建立关联表（Order_Details(Order_id,article_id)）</p></blockquote><p>在索引中字段顺序很重要，可能会影响某引数量，导致多余索引的情况，从而影响性能</p><blockquote><p>e.g. 在上例中，如果Order_id在前，表会缺省地构建一个order_id和article_id的复合键索引，然后要手动为外键构建索引，Order_id不需要索引，因为跟复合键索index（o,a）引本质一样，因此只需要构建article_id的索引，而article是商品表，不太被修改，符合字典表原则，因此不需要构建索引。综上，只需对复合键构建索引，不需单独索引，仅有一个索引</p><p>如果a在前，系统会构建一个a_id为主的复合键索引，同时要手工构建o_id的外键索引，因为order这张表要频繁更改，构建外键索引是必要的。综上，引入了额外的索引</p></blockquote><h4 id="2-5-自增字段-系统生成键"><a href="#2-5-自增字段-系统生成键" class="headerlink" title="2.5 自增字段 系统生成键"></a>2.5 自增字段 系统生成键</h4><p>构建数据库有时需要唯一的流水号作为主键，往往用自增字段/系统生成键来实现</p><h5 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h5><p>系统提供的自增字段性能很高，使用系统提供的自增字段是最佳选择，远好于自己实现，系统会自动为当前自增字段构建主键索引以保证其唯一性</p><ul><li><p>自己实现：</p><p>需要存储一个最大值，而这个最大值势必成为资源竞争的节点，所有的插入必须先读取该最大值，然后进行+1，再存储，此时该字段值只能串行化，无法支持并发</p></li></ul><h5 id="资源竞争"><a href="#资源竞争" class="headerlink" title="资源竞争"></a>资源竞争</h5><p>如果用自增字段来实现系统生成键，可能会引发并发问题：插入并发性过高，在主键索引的创建操作上会发生严重的资源竞争问题</p><p>主键索引的主要作用是保障主键的唯一性，如果仅存在一个系统生成键的生成器，生成的序列号就会很接近，在插入键值的过程中，所有的进程都会争夺相同的索引的page和块，而请求需要串行化各个进程，利用合适锁定机制来避免一个进程的复写(overwrite)。尽管在基本表的插入中由于堆文件、随机文件的存在使得基本表可以支持高并发的同时写入，但在索引写入上只能支持串行，即一个接一个的操作，这时就会出现瓶颈</p><h5 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h5><p>反向键索引/逆向索引（reverse index）</p><ul><li><p>特殊的函数索引，将字段值反过来（9527-&gt;7259）</p><p>如果有连续的记录并发插入，他们大概率会在索引结构上同一个叶节点的块中，此时必须要排队竞争该具体块从而插入</p><p>反向键索引使得连续的值变得相差很远，他们大概率会落在索引结构的不同叶节点上，这时可以同时插入不同的块，不需要竞争</p></li></ul><p>哈希索引(hash index)</p><ul><li>组织形式与b树索引类似，将值与等长数值（哈希值）对应起来，将哈希值组成索引结构</li><li>与上一个方法类似，本质是将连续的内容离散化</li></ul><h5 id="该不该用毫无意义的字段作为主键，会带来什么问题（内容来自网络）"><a href="#该不该用毫无意义的字段作为主键，会带来什么问题（内容来自网络）" class="headerlink" title="该不该用毫无意义的字段作为主键，会带来什么问题（内容来自网络）"></a>该不该用毫无意义的字段作为主键，会带来什么问题（内容来自网络）</h5><p>优点：</p><ul><li>数据库自动编号，速度快，而且是增量增长，按顺序存放，对于检索非常有利；</li><li>数字型，占用空间小，易排序，在程序中传递也方便；</li><li>如果通过非系统增加记录时，可以不用指定该字段，不用担心主键重复问题</li></ul><p>缺点：</p><ul><li>在系统集成或割接时，如果新旧系统主键不同是数字型就会导致修改主键数据类型，这也会导致其它有外键关联的表的修改，后果同样很严重</li><li>高并发的情况下，竞争自增锁会降低数据库的吞吐能力</li><li>导入旧数据时，可能会ID重复，导致导入失败</li><li>分布式架构，多个Mysql实例可能会导致ID重复</li></ul><h3 id="3-SQL"><a href="#3-SQL" class="headerlink" title="3. SQL"></a>3. SQL</h3><h4 id="3-1-执行顺序"><a href="#3-1-执行顺序" class="headerlink" title="3.1 执行顺序"></a>3.1 执行顺序</h4><p>解析最消耗资源，是高效执行/优化的切入口。解析对每一次的表达式进行等价变换，生成解析树进行评估，最终形成执行计划，将计划抛入执行引擎中，进行查询，解析+生成执行计划是查询优化器最重要的工作</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/sql/2.jpg" alt="执行顺序"></p><h4 id="3-2-优化方式"><a href="#3-2-优化方式" class="headerlink" title="3.2 优化方式"></a>3.2 优化方式</h4><ul><li>使用好的过滤条件</li><li>降低表连接的数量</li></ul><h5 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h5><ul><li><p>含义</p><p>join过滤条件——on，用于连接表</p><p>select过滤条件——where，与需求、业务相关</p></li><li><p>过滤条件的好坏</p><p>过滤条件是否高效：是否能够尽快减少必须处理的数据总量</p><p>好的过滤条件需要先做，在复杂的、高并发的查询中，将好的过滤条件先做，可以有效减少中间结果集的大小，从而提高效率</p></li></ul><h5 id="用exists嵌套子查询摆脱distinct"><a href="#用exists嵌套子查询摆脱distinct" class="headerlink" title="用exists嵌套子查询摆脱distinct"></a>用exists嵌套子查询摆脱distinct</h5><p>子查询和外层select关系很密切，但会执行很多次，这时如果在exists前使用较高效的过滤条件可以有效减少exists的执行次数</p><h5 id="in构建非关联子查询"><a href="#in构建非关联子查询" class="headerlink" title="in构建非关联子查询"></a>in构建非关联子查询</h5><p>在关联子查询中，相关字段要有索引，而非关联子查询不需要，因为要用到的索引是主键索引，内层查询不再依赖外层查询，只需要执行一次</p><h4 id="3-3-表结构"><a href="#3-3-表结构" class="headerlink" title="3.3 表结构"></a>3.3 表结构</h4><h5 id="回头看看订单和客户的例子"><a href="#回头看看订单和客户的例子" class="headerlink" title="回头看看订单和客户的例子"></a>回头看看订单和客户的例子</h5><h5 id="降低表连接数量-gt-反范式-逆范式"><a href="#降低表连接数量-gt-反范式-逆范式" class="headerlink" title="降低表连接数量-&gt;反范式/逆范式"></a>降低表连接数量-&gt;反范式/逆范式</h5><p>反范式化为了提升查询效率而考虑把原本符合第三范式的表适当增冗余，减少表连接数量</p><p>合并1对1关系</p><ul><li><p>以全部参与的表为主，引入部分参入的表</p><blockquote><p>e.g. staff与nok(紧急联系人)是1对1，每个nok都对应一个staff，但不是每个staff都有nok，nok部分参与。对两表进行合并，以staff为主，引入nok</p></blockquote></li><li><p>问题：</p><ul><li>空值问题</li><li>如果全部参与的表很大，部分参与的表很小，会造成空间浪费</li><li>如果两个表对于彼此都是部分参与，那么还需手动引入主键</li></ul></li></ul><p>为减少连接操作，在1对多关系中复制非关键字属性</p><ul><li>注意复制过来的属性的更新，需要触发器来进行两张表的同步更新</li><li>一般对于钱这种属性，都需要打破范式进行存储</li></ul><p>为减少连接操作，在1对多关系中复制外部关键字</p><ul><li>与上述内容类似</li></ul><p>为减少连接操作，在多对多关系中复制非关键字属性</p><p>引入重复组</p><ul><li>把重复组打包放进主表中（不通用）</li><li>主表中存放缺省的一个值，等需要详细的全部内容时再访问相应的地址表和基本表</li></ul><p>合并基本表和查找表，创建提取表</p><ul><li>将查询慢的表全部连接起来形成一张大表</li><li>不到必要不要使用，虽然很强大，但会带来很大的复杂性</li></ul><p>分区（存储层面的逆范式）</p><h3 id="4-数据库的事务隔离级别"><a href="#4-数据库的事务隔离级别" class="headerlink" title="4. 数据库的事务隔离级别"></a>4. 数据库的事务隔离级别</h3><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/sql/3.jpg" alt="隔离级别"></p><h4 id="相关计算"><a href="#相关计算" class="headerlink" title="相关计算"></a>相关计算</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>一个事务读到另一个事务修改但未提交的数据时，就可能发生脏读</p><p>e.g. from ppt</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line">UPDATE users <span class="keyword">SET</span> dept_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* No commit here */</span></span><br><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 2 */</span></span><br></pre></td></tr></table></figure><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>（ppt）在当执行SELECT 操作时没有获得读锁或SELECT操作执行完后马上释放了读锁; 另外一个事务对数据进行了更新,读到了不同的结果</p><p>（网络版本）在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了</p><p>e.g. 事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line">UPDATE users <span class="keyword">SET</span> dept_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">/* No commit here */</span></span><br><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">/* 结果是 2 */</span></span><br></pre></td></tr></table></figure><p>注意，虽然你知道事务2改了，但是事务1可能不知道，连读两次数不一样的场面就很惊悚</p><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>是不可重复读的一种特殊场景，主要针对增和删</p><ul><li><p>当事务1两次执行’’SELECT … WHERE’’检索一定范围内数据的操作中间</p></li><li><p>事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的 “WHERE”子句。</p></li></ul><p>e.g. from Internet</p><p>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读</p><h5 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h5><p>脏读：读到了别的事物未提交的数据</p><p>不可重复读：读到了其他事务已经提交的数据</p><p>幻读：不可重复读的特殊场景</p><ul><li>不可重复读与幻读都是读到其他事务已提交的数据，但是它们针对点不同.</li><li>不可重复读:update.</li><li>幻读:delete，insert</li></ul><h4 id="四种级别（如果你嫌弃我的例子炒前面的冷饭那就自己举！）"><a href="#四种级别（如果你嫌弃我的例子炒前面的冷饭那就自己举！）" class="headerlink" title="四种级别（如果你嫌弃我的例子炒前面的冷饭那就自己举！）"></a>四种级别（如果你嫌弃我的例子炒前面的冷饭那就自己举！）</h4><h5 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h5><p>是最低的隔离级别，在这种隔离级别下，如果一个事务 已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据</p><p>在此隔离级别下，一个事务能够读到其他事务未提交的数据，因此可能存在脏读问题</p><p>e.g. (前面脏读的例子罢了)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line">UPDATE users <span class="keyword">SET</span> dept_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* No commit here */</span></span><br><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 2 */</span></span><br></pre></td></tr></table></figure><p>隔离级别低到连其他未提交的数据都可以读到，因此可重复读和幻读问题也不可避免，举例与上述幻读和不可重复读一致</p><h5 id="已提交读"><a href="#已提交读" class="headerlink" title="已提交读"></a>已提交读</h5><p>读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务 访问该行，会对该写锁一直保持直到到事务提交</p><p>e.g. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line">UPDATE users <span class="keyword">SET</span> dept_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* No commit here ,But locked*/</span></span><br><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* waiting waiting/</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br></pre></td></tr></table></figure><p>解释：在事务2更新某条数据的时候，如果没有commit，那么针对此条数据的写锁一直保持，当事务1想要读时会因为写锁被阻塞，直到事务2commit或者rollback，写锁解除，才可以读</p><p>但是防不了不可重复读的问题，即事务2 commit提交以后，事务1在前后两次读取相同行的内容是不同的</p><p>e.g. (前面不可重复读的例子罢了)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="comment">/* 结果是 1 */</span></span><br><span class="line"><span class="comment">/*事务2*/</span></span><br><span class="line">UPDATE users <span class="keyword">SET</span> dept_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">/*事务1*/</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_id <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">/* 结果是 2 */</span></span><br></pre></td></tr></table></figure><p>幻读作为不可重复读的特殊场景同样在这一隔离级别难以被避免（笔者此时心态崩了，不想写了，反正就事务2插入了，然后事务1恍惚间发现多了一条数据，就很迷）</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/sql/4.jpg" alt="图"></p><h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>从名字就可以知道，它可以避免不可重复读的问题</p><p>一个事务在执行过程中，<strong>可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务）</strong>，写事务则禁止任何其他事务。此隔离级别可有效防止不可重复读和脏读，但防不住幻读，下图应该很清楚了，我就不解释了</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/sql/5.jpg" alt="图"></p><h5 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h5><p>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。此隔离级别可有效防止脏读、不可重复读和幻读。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本复习提纲由Dart完成整理。&lt;/p&gt;
&lt;p&gt;内容没有按题号来，主要按6+上课复习涉及到的知识点&lt;/p&gt;
&lt;h3 id=&quot;1-B-树索引&quot;&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MySQL" scheme="https://icimence.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux程设复习提纲（三）</title>
    <link href="https://icimence.cn/2021/04/21/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://icimence.cn/2021/04/21/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-04-21T11:55:43.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chapter3-1（续）"><a href="#Chapter3-1（续）" class="headerlink" title="Chapter3-1（续）"></a>Chapter3-1（续）</h3><h3 id="系统调用（掌握）和库函数（当题目指定系统调用时不能使用）"><a href="#系统调用（掌握）和库函数（当题目指定系统调用时不能使用）" class="headerlink" title="系统调用（掌握）和库函数（当题目指定系统调用时不能使用）"></a>系统调用（掌握）和库函数（当题目指定系统调用时不能使用）</h3><p>系统调用和库函数都以C函数的形式出现</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li>Linux内核的对外接口</li><li>用户程序和内核之间唯一的接口</li><li>提供最小接口</li></ul><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><ul><li>依赖于系统调用</li><li>提供复杂功能（例如：标准I/O库）</li></ul><h4 id="以I-O作为样例"><a href="#以I-O作为样例" class="headerlink" title="以I/O作为样例"></a>以I/O作为样例</h4><ul><li>非缓存IO<ul><li>读写操作直接调用系统调用</li><li>文件描述符</li><li>Not in ANSI C, but in POSIX.1 and XPG3</li></ul></li><li>缓存IO<ul><li>使用标准IO库</li><li>处理很多细节，如缓存分配以及优化长度执行IO</li><li>流是一个文件中的指针</li></ul></li></ul><h4 id="系统IO调用"><a href="#系统IO调用" class="headerlink" title="系统IO调用"></a>系统IO调用</h4><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><p>一个非负的整形（如在<unistd.h>文件中STDIN_FILENO (0), STDOUT_FILENO (1), STDERR_FILENO (2)）</p><p>一般的文件操作的步骤：打开，读/写，（lseek），关闭</p><h5 id="基本的IO函数"><a href="#基本的IO函数" class="headerlink" title="基本的IO函数"></a>基本的IO函数</h5><p>先给一个文件的最简单的读写样例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a rudimentary example program */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> fd, nread;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">/*open file “data” for reading */</span></span><br><span class="line">fd = open(“data”, O_RDONLY);</span><br><span class="line"><span class="comment">/* read in the data */</span></span><br><span class="line">nread = read(fd, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">/* close the file */</span></span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="open-creat方法"><a href="#open-creat方法" class="headerlink" title="open/creat方法"></a>open/creat方法</h6><p>用于打开或者创建一个文件或者设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">(Return: a <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure><p>flags参数：文件的访问模式</p><ul><li>O_RDONLY：只读操作</li><li>O_WRONLY：只写操作</li><li>O_RDWR：读写操作</li><li>O_APPEND：文件以追加（append）模式打开</li><li>O_TRUNC：如果文件已经存在且是一个常规文件且允许以写模式打开则截断该文件长度为0（清空文件？）</li><li>O_CREAT：如果文件不存在则被创建</li><li>O_EXCL：和O_CREAT一起使用，如果文件已经存在则是一个错误且打开文件失败。</li></ul><p>creat方法等价于以（O_CREAT|O_WRONLY|O_TRUNC）作为flag使用open方法</p><p>mode参数：指定创建新文件的权限，列表如下：</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/20.png" alt="mode参数"></p><p>新建文件权限由mode和umask共同决定，如图</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/21.png" alt="文件权限"></p><h6 id="close方法"><a href="#close方法" class="headerlink" title="close方法"></a>close方法</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">(Return: <span class="number">0</span> <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure><ul><li>主要系统调用要求掌握，指定系统调用的题不能用C库</li><li>进程相关的系统调用不要求掌握</li><li>LCTL不考</li><li>C库简答题可能要考</li><li>权限要掌握</li><li>文件锁要求掌握，扩展的文件锁不要求掌握</li><li>锁的标志位不要求掌握</li><li>锁的系统调用要求掌握</li></ul><h6 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read/write函数"></a>read/write函数</h6><ul><li>从一个文件描述符进行读取</li><li>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line">(返回值: 读到的字节数，若已到文件尾为<span class="number">0</span>，若出错为<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 写到一个文件描述符</span><br><span class="line"></span><br><span class="line">```c </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">(返回值: 若成功为已写的字节数，若出错为-1)</span><br></pre></td></tr></table></figure></li></ul><h6 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h6><p>用于重新计算读写的偏移量</p><p>用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line">(Return: the resulting offset location <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure><p>关于whence参数</p><blockquote><p><strong>SEEK_SET:</strong> the offset is set to “offset” bytes,这个表示把文件指针放在你设置的偏移量的位置。<br><strong>SEEK_CUR:</strong> the offset is set to its current location plus “offset” bytes，这个表示文件指针的位置设置在当前位置加上你设置的offset值的位置。<br><strong>SEEK_END:</strong> the offset is set to the size of the file plus “offset” bytes，这个表示文件指针的位置是文件末尾的位置加上设置的offset值的和的位置。</p></blockquote><h6 id="dup-dup2函数"><a href="#dup-dup2函数" class="headerlink" title="dup/dup2函数"></a>dup/dup2函数</h6><p>复制一个文件描述符，返回一个新的文件描述符，指向同一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line">(Return: the <span class="keyword">new</span> file descriptor <span class="keyword">if</span> success; <span class="number">-1</span> <span class="keyword">if</span> failure)</span><br></pre></td></tr></table></figure><h6 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h6><p>对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br><span class="line">(返回值: 若成功则依赖于cmd，若出错为<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>cmd参数</p><ul><li>F_DUPFD：和dup函数相同</li><li>F_GETFD/F_SETFD：get/set文件的close-on-exec标志</li><li>F_GETFL/F_SETFL：get/set文件打开方式的标识</li><li>F_GETOWN/F_SETOWN：get/set文件的IO能力标识</li><li>F_GETLK/F_SETLK/F_SETLKW：获得，设置文件锁（封锁，解封），第二个在设置时如果失败会导致直接结束并返回，第三个是会阻塞自身等待文件解锁</li></ul><h6 id="ioctl函数"><a href="#ioctl函数" class="headerlink" title="ioctl函数"></a>ioctl函数</h6><p>控制设备的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="标准I-O库"><a href="#标准I-O库" class="headerlink" title="标准I/O库"></a>标准I/O库</h5><h3 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h3><p>当几个进程同时操作文件时起到作用</p><ul><li><p>记录锁</p></li><li><p>劝告锁</p><blockquote><p>检查，加锁由应用程序自己控制</p></blockquote></li><li><p>强制锁</p><blockquote><p>检查，加锁由内核控制</p><p>影响open，read，write等函数</p></blockquote></li><li><p>共享锁</p></li><li><p>排他锁</p></li></ul><h4 id="fcntl设置锁"><a href="#fcntl设置锁" class="headerlink" title="fcntl设置锁"></a>fcntl设置锁</h4><p>上文<a href="#fcntl函数">系统调用中的fcntl</a>已经有cmd参数的详细介绍，这里不再做赘述，主要讲一下struct flock的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock *lock)</span></span>;</span><br><span class="line">(返回值: 若成功则依赖于cmd，若出错为<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">short</span> l_type; <span class="comment">/* Type of lock: F_RDLCK, F_WRLCK, F_UNLCK */</span></span><br><span class="line"><span class="keyword">short</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line"><span class="keyword">off_t</span> l_start; <span class="comment">/* Starting offset for lock */</span></span><br><span class="line"><span class="keyword">off_t</span> l_len; <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line"><span class="keyword">pid_t</span> l_pid; <span class="comment">/* PID of process blocking our lock (F_GETLK only) */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><h3 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h3><p>操作系统是一系列程序的集合，其中最重要的部分构成了内核。</p><h4 id="单内核-微内核"><a href="#单内核-微内核" class="headerlink" title="单内核/微内核"></a>单内核/微内核</h4><ul><li>单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现</li><li>微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯</li></ul><h4 id="Linux内核的能力"><a href="#Linux内核的能力" class="headerlink" title="Linux内核的能力"></a>Linux内核的能力</h4><ul><li>内存管理，文件系统，进程管理，多线程支持，抢占式，多处理支持</li></ul><h4 id="Linux内核区别于其他UNIX商业内核的优点"><a href="#Linux内核区别于其他UNIX商业内核的优点" class="headerlink" title="Linux内核区别于其他UNIX商业内核的优点"></a>Linux内核区别于其他UNIX商业内核的优点</h4><ul><li>单内核，模块支持</li><li>免费/开源</li><li>支持多种CPU，硬件支持能力非常强大</li><li>Linux开发者都是非常出色的程序员</li><li>通过学习Linux内核的源码可以了解现代操作系统的实现原理</li></ul><h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>常见的驱动代码集成在内核源码中</p><p>也有第三方开发的驱动可以单独编译为模块.ko文件</p><p>编译需要内核头文件的支持</p><h4 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h4><ul><li>底层命令<ul><li>insmod</li><li>rmmod</li></ul></li><li>高层命令<ul><li>modprobe</li><li>modprobe -r</li></ul></li></ul><h4 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h4><p>一个模块A应用另一个模块B所导出的符号我们就说模块B被模块A引用，如果要装载A，则必须要线装载B，否则，模块B所导出的那些符号的应用就不可能被链接到A中，这就叫模块的依赖</p><p>系统可以实现自动按需加载以及自动按需卸载</p><p>moddep，ismod，modinfo</p><h4 id="模块之间的通讯"><a href="#模块之间的通讯" class="headerlink" title="模块之间的通讯"></a>模块之间的通讯</h4><p>模块是为了完成某种特定任务而设计的，功能单一，为了丰富系统的功能，所以模块之间常常需要通信，可以共享<strong>变量，数据结构，调用对方的功能函数</strong></p><h4 id="模块的命令"><a href="#模块的命令" class="headerlink" title="模块的命令"></a>模块的命令</h4><ul><li>insmod <module.ko> [module parameters]<ul><li>用于装载模块</li><li>注意：只有超级用户能够使用这个命令</li></ul></li><li>rmmod<ul><li>卸载模块</li></ul></li><li>lsmod<ul><li>查看内核中已经装载的所有模块</li><li>这个命令和cat /proc/modules等价</li></ul></li><li>modprobe [-r] \<module name\><ul><li>装载一个模块以及这个模块依赖的所有模块</li></ul></li></ul><h4 id="Linux内核模块和应用程序的区别"><a href="#Linux内核模块和应用程序的区别" class="headerlink" title="Linux内核模块和应用程序的区别"></a>Linux内核模块和应用程序的区别</h4><div class="table-container"><table><thead><tr><th></th><th>C语言程序</th><th>Linux内核模块</th></tr></thead><tbody><tr><td>运行</td><td>用户空间</td><td>内核空间</td></tr><tr><td>入口</td><td>main</td><td>module_init()指定</td></tr><tr><td>出口</td><td>无</td><td>module_exit()指定</td></tr><tr><td>运行</td><td>直接运行</td><td>insmod</td></tr><tr><td>调试</td><td>gdb</td><td>kdbug,kdb,kgdb</td></tr></tbody></table></div><p>内核模块不能使用C库进行开发</p><p>没有内存保护机制</p><p>小内核栈</p><p>需要考虑并发</p><p>一个简单的内核模块的代码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;Goodbye world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/22.png" alt="内核模块解释"></p><h3 id="内核程序和用户态程序区别"><a href="#内核程序和用户态程序区别" class="headerlink" title="内核程序和用户态程序区别"></a>内核程序和用户态程序区别</h3><p>内核态和用户态是处理器的两个状态</p><p>当发生中断或者系统调用时暂停正在运行的进程，把处理器状态从用户态转到内核态，执行操作系统服务例程。这就是一次状态转换，此时进程仍然在自己的上下文中执行，仅处理器状态发生了变化，内核在被中断的进程的上下文中进行处理。</p><p>在大多数情况下处理器状态的转换不会影响到上下文。</p><h3 id="读懂内核程序代码"><a href="#读懂内核程序代码" class="headerlink" title="读懂内核程序代码"></a>读懂内核程序代码</h3><p>实在过于硬核，代码长达5页pdf，可以自行学习，在最后一个PDF的第25页开始</p><h3 id="字符型驱动程序概念"><a href="#字符型驱动程序概念" class="headerlink" title="字符型驱动程序概念"></a>字符型驱动程序概念</h3><p>Linux系统将设备分为三种类型：字符设备、块设备和网络接口设备</p><p>文件操作是字符设备驱动的对上接口</p><p>两个基本的结构体分别是：file结构体和inode结构体</p><p>驱动程序的初始化加载过程是</p><ul><li>申请设备号</li><li>定义文件操作结构体file_operations</li><li>创建并初始化定义结构体cdev</li><li>将cdev注册到系统，并和对应的设备号绑定</li><li>在/dev文件系统中用mknod创建设备文件，并将该文件绑定到设备号上</li></ul><p>每个字符设备或者是块设备都有主设备号和次设备号，主设备号表示一个特定的驱动程序，次设备号用来表示使用该驱动程序的各设备。</p><p><em>注：申请设备号之后的内容过于繁琐，个人认为不考，可以从参考pdf</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Chapter3-1（续）&quot;&gt;&lt;a href=&quot;#Chapter3-1（续）&quot; class=&quot;headerlink&quot; title=&quot;Chapter3-1（续）&quot;&gt;&lt;/a&gt;Chapter3-1（续）&lt;/h3&gt;&lt;h3 id=&quot;系统调用（掌握）和库函数（当题目指定系统调</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://icimence.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux程设复习提纲（二）</title>
    <link href="https://icimence.cn/2021/04/20/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://icimence.cn/2021/04/20/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-04-20T12:55:20.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter3-0"><a href="#Chapter3-0" class="headerlink" title="Chapter3-0"></a>Chapter3-0</h2><h3 id="编译链接理解"><a href="#编译链接理解" class="headerlink" title="编译链接理解"></a>编译链接理解</h3><p>常用的开发工具：GCC，GDB，二进制库，make</p><ul><li><p>windows环境下的编译链接图</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/8.png" alt="windows编译链接"></p></li><li><p>编译链接图</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/9.png" alt="编译链接"></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/10.png" alt="编译链接"></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/11.png" alt="编译链接"></p></li></ul><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><ol><li>预处理（头文件）</li><li>编译（转为汇编程序）</li><li>汇编（转为目标文件.o）</li><li>链接（引入C库）</li></ol><p>在编译链接中头文件和#include分别是预处理和编译时处理</p><p>为什么要做链接（可能是因为要引入C库中的函数？我不清楚）</p><h4 id="库和头文件"><a href="#库和头文件" class="headerlink" title="库和头文件"></a>库和头文件</h4><p>静态库和动态库的区别就在于链接这一个步骤中如何处理库</p><h5 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h5><p>.a文件，gcc ar即可使用静态链接</p><p>在连接过程中将所有的函数库和.o文件进行连接，在编译（广义）时就已经完成了，程序在运行是与函数库没有关系，移植方便，但是因为函数库较多，所以浪费空间和资源，所有涉及到的代码会合并到一个可执行文件。</p><h5 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h5><p>动态库的出现是因为静态库对于空间的浪费比较大，并且如果有软件厂商试图对静态库进行更新，需要更新整个静态库，非常耗费资源，需要<strong>全量更新</strong>。</p><p>动态库在程序编译（广义）是不会被链接到代码中，而是在运行的时候才会进行载入，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，节省了空间。实现了资源的共享</p><p><em>参考文章：<a href="https://www.cnblogs.com/skynet/p/3372855.html">博客园文章</a></em></p><h4 id="其他语言的编译过程（非重点）"><a href="#其他语言的编译过程（非重点）" class="headerlink" title="其他语言的编译过程（非重点）"></a>其他语言的编译过程（非重点）</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/12.png" alt="编译过程"></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/13.png" alt="delphi编译"></p><h3 id="gcc命令参数"><a href="#gcc命令参数" class="headerlink" title="gcc命令参数"></a>gcc命令参数</h3><p>gcc用于编译C，gcc可以链接或者编译+链接</p><p>g++用于CPP</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>-E：只对源程序进行预处理</li><li>-S：只对源程序进行预处理和编译</li><li>-c：执行预处理、编译、汇编而不链接</li><li>-o outputFile 指定输出文件名</li><li>-g：产生调试工具必须的符号信息</li><li>-O/On：在整个编译、链接过程中进行优化处理</li><li>-Wall：显示所有的警告信息</li><li>-Idir：指定额外的头文件搜索路径</li><li>-Ldir：指定额外的库文件的搜索路径</li><li>-lname：链接时搜索指定的库文件</li><li>-DMACRO[=DEFN]：定义MACRO宏</li></ul><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><div class="table-container"><table><thead><tr><th>文件尾缀</th><th>文件类型</th></tr></thead><tbody><tr><td>.c</td><td>一定会被预处理的C源码文件</td></tr><tr><td>.i</td><td>不应该被预处理的C源码文件</td></tr><tr><td>.cc .cp .cpp .CPP .c++ .C .cxx</td><td>一定会被预处理的CPP源码文件</td></tr><tr><td>.ii</td><td>不应该被预处理的CPP源码文件</td></tr><tr><td>.h</td><td>C或者CPP的头文件</td></tr><tr><td>.H .hh</td><td>CPP的头文件</td></tr><tr><td>.s</td><td>汇编码</td></tr><tr><td>.S</td><td>必须被预处理的汇编码</td></tr><tr><td>.o</td><td>object file不会翻译</td></tr><tr><td>.a</td><td>静态库文件</td></tr><tr><td>.so</td><td>动态库文件</td></tr></tbody></table></div><h3 id="GDB（不要求，做了解）"><a href="#GDB（不要求，做了解）" class="headerlink" title="GDB（不要求，做了解）"></a>GDB（不要求，做了解）</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/15.png" alt="gdb"></p><h3 id="Makefile读和写（要了亲命，我怎么知道什么是简单的读和写）"><a href="#Makefile读和写（要了亲命，我怎么知道什么是简单的读和写）" class="headerlink" title="Makefile读和写（要了亲命，我怎么知道什么是简单的读和写）"></a>Makefile读和写（要了亲命，我怎么知道什么是简单的读和写）</h3><h4 id="make-amp-makefile"><a href="#make-amp-makefile" class="headerlink" title="make &amp; makefile"></a>make &amp; makefile</h4><p>makefile描述模块间的依赖关系</p><p>make命令根据makefile对程序进行管理和维护，make判断被维护文件的时序关系</p><p>我裂开了，这一块实在是没法整，参考pdf，Ch3-0从第25页开始（痛苦面具），一下makefile内容均是本人的理解。</p><h4 id="make命令"><a href="#make命令" class="headerlink" title="make命令"></a>make命令</h4><p>有了make命令就可以实现整个工程完全自动编译，make是一个命令工具。</p><p>make的命令格式：make [-f Makefile] [option] [target]</p><blockquote><p>如：make target；make；make clean</p></blockquote><p>make命令的Targets</p><ul><li><p>通常是一个被生成的文件的名字，如可执行文件或者.o文件</p></li><li><p>target也可以是一个动作，如make clean中的clean（伪目标）</p></li></ul><h4 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target...:prerequisites ...</span></span><br><span class="line"></span><br><span class="line">command</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>target是一个目标文件，可以是.o文件，也可以是执行文件</li><li>prerequisites是要生成target所需要的文件或是目标</li><li>command是make需要执行的命令（可以是任意的shell命令）</li></ul><p>如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello : main.o kbd.o</span><br><span class="line">gcc -o hello main.o kbd.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c</span><br><span class="line">clean :</span><br><span class="line">rm edit main.o kbd.o</span><br></pre></td></tr></table></figure><h4 id="Makefile执行的次序"><a href="#Makefile执行的次序" class="headerlink" title="Makefile执行的次序"></a>Makefile执行的次序</h4><ol><li>make会在当前目录下找到名字叫Makefile或makefile的文件</li><li>查找文件中的第一个目标文件（target），举例中的hello</li><li>如果hello文件不存在或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件</li><li>如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件（类似一个堆栈的过程）</li><li>make根据.o文件的规则生成.o文件，然后再用.o文件生成hello文件</li></ol><h4 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h4><p>如hello示例中的clean动作中的命令</p><ul><li>伪目标不是一个文件，只是一个标签，所以make无法解析他的依赖关系和决定是否要执行。所以要执行一定要make clean</li><li>伪目标的取名不能和文件名重名</li><li>为了避免和文件重名的情况，可以使用标记”.PHONY”来指明一个目标是伪目标</li><li>伪目标一般没有依赖的文件，但可以有</li><li>伪目标同样可以放在第一个作为默认目标</li></ul><h4 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h4><p>当多个目标同时依赖于一个文件，并且其生成的命令大体类似，可以使用一个自动化变量“$@”表示着目前规则中所有的目标的集合</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure><h4 id="一个例子（我看不太懂）"><a href="#一个例子（我看不太懂）" class="headerlink" title="一个例子（我看不太懂）"></a>一个例子（我看不太懂）</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TOPDIR = ../</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(TOPDIR)</span>Rules.mak</span><br><span class="line">EXTRA_LIBS +=</span><br><span class="line">EXEC = <span class="variable">$(INSTALL_DIR)</span>/hello</span><br><span class="line">OBJS = hello.o</span><br><span class="line"><span class="section">all: <span class="variable">$(EXEC)</span></span></span><br><span class="line"><span class="variable">$(EXEC)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(EXTRA_LIBS)</span></span><br><span class="line"><span class="section">install:</span></span><br><span class="line"><span class="variable">$(EXP_INSTALL)</span> <span class="variable">$(EXEC)</span> <span class="variable">$(INSTALL_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -f <span class="variable">$(EXEC)</span> *.elf *.gdb *.o</span><br></pre></td></tr></table></figure><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><ul><li>$&lt; 第一个依赖文件的名称</li><li>$? 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li><li>$+所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li><li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li><li>$* 不包括扩展名的目标文件名称</li><li>$@ 目标的完整名称</li><li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li></ul><h4 id="多目标扩展"><a href="#多目标扩展" class="headerlink" title="多目标扩展"></a>多目标扩展</h4><ul><li><p>语法</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">&lt;commands&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>举例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><ul><li>目标从$object中获取</li><li>“%.o”表明要所有以“.o”结尾的目标，即“foo.o bar.o”，就是变量$object集合的模式</li><li>依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”</li></ul><p>上述代码等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="makefile中的函数（仅需掌握，不需要会使用）"><a href="#makefile中的函数（仅需掌握，不需要会使用）" class="headerlink" title="makefile中的函数（仅需掌握，不需要会使用）"></a>makefile中的函数（仅需掌握，不需要会使用）</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/19.png" alt="makefile的函数"></p><h2 id="Chapeter3-1"><a href="#Chapeter3-1" class="headerlink" title="Chapeter3-1"></a>Chapeter3-1</h2><h3 id="七种文件类型"><a href="#七种文件类型" class="headerlink" title="七种文件类型"></a>七种文件类型</h3><ul><li>普通文件<ul><li>文本和数据，没有特别的内部结构</li></ul></li><li>字符设备文件<ul><li>穿行端口的接口设备，例如键盘、鼠标</li></ul></li><li>块设备文件<ul><li>存储数据以供系统存取的接口设备，如键盘</li></ul></li><li><p>套接字文件</p><ul><li>用在网络数据连接</li></ul></li><li><p>管道文件</p><ul><li>解决多个程序同时存取一个文件造成的错误</li></ul></li><li>链接文件<ul><li>类似快捷方式</li></ul></li></ul><h3 id="VFS主要原理，四种结构类型"><a href="#VFS主要原理，四种结构类型" class="headerlink" title="VFS主要原理，四种结构类型"></a>VFS主要原理，四种结构类型</h3><p>VFS虚拟文件系统，是一个对各个文件系统提供统一的操作界面和编程接口的一个系统 ，可以直接使用read(),write(),open()函数而不需要关注底层的实现</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/16.png" alt="VFS"></p><p>VFS只存在在内存中，有四种结构类型</p><ul><li>超级块对象(super block)</li><li>索引节点对象(i-node object)</li><li>目录项对象(dentry object)</li><li>文件对象(file object)</li></ul><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/17.png" alt="VFS四种结构类型"></p><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul><li>不同的文件名对应同一个inode</li><li>不能跨越文件系统</li><li>对应系统调用link</li></ul><h4 id="软连接（符号链接）"><a href="#软连接（符号链接）" class="headerlink" title="软连接（符号链接）"></a>软连接（符号链接）</h4><ul><li>存储被链接文件的文件名（而不是inode）实现链接</li><li>可跨越系统调用</li><li>对应系统调用symlink</li></ul><a class="btn-beautify block right red larger" href="https://icimence.cn/2021/04/21/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/"   title="Linux程设复习提纲（三）"><i class="far fa-hand-point-right"></i><span>Linux程设复习提纲（三）</span></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter3-0&quot;&gt;&lt;a href=&quot;#Chapter3-0&quot; class=&quot;headerlink&quot; title=&quot;Chapter3-0&quot;&gt;&lt;/a&gt;Chapter3-0&lt;/h2&gt;&lt;h3 id=&quot;编译链接理解&quot;&gt;&lt;a href=&quot;#编译链接理解&quot; class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://icimence.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux程设复习提纲（一）</title>
    <link href="https://icimence.cn/2021/04/19/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://icimence.cn/2021/04/19/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-04-19T09:53:48.000Z</published>
    <updated>2022-03-26T14:13:50.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="Linux是怎样的一个系统"><a href="#Linux是怎样的一个系统" class="headerlink" title="Linux是怎样的一个系统"></a>Linux是怎样的一个系统</h3><p>Linux是一个免费的遵循GPL（GNU General Public License）原则开发的类Unix操作系统（开源的，受欢迎的，支持大多数可用平台）</p><h3 id="Linux常用发行版"><a href="#Linux常用发行版" class="headerlink" title="Linux常用发行版"></a>Linux常用发行版</h3><p>RedHat，Debian，SuSe，Mandrake，Redflag</p><h3 id="Linux安装（不考？）"><a href="#Linux安装（不考？）" class="headerlink" title="Linux安装（不考？）"></a>Linux安装（不考？）</h3><ul><li>Boot system from bootable media</li><li>All installation programs need to perform essentially the same steps:<ul><li>Choose language, keyboard type, mouse type</li><li>Create partitions **</li><li>Setup a boot loader  **</li><li>Configure network</li><li>Configure user and authentication</li><li>Select package groups</li><li>Configure X</li><li>Install packages</li><li>Create boot disk</li></ul></li></ul><h3 id="引导程序的作用"><a href="#引导程序的作用" class="headerlink" title="引导程序的作用"></a>引导程序的作用</h3><p>主引导记录是一个512字节的硬盘第一扇区，446字节的代码，64字节的分区表，2字节的魔术字符</p><ul><li>一个引导会装载并启动Linux内核<ul><li>可以给Linux内核传递启动需要的参数如设备信息</li><li>可以选择性的加载一个初始化的根磁盘</li><li>可以启动其他的操作系统</li></ul></li><li><p>常用的引导程序</p><ul><li><p>LILO：Linux Loader</p><blockquote><p>一个按照配置文件设置MBR的程序，一定要使用超级用户运行lilo命令才行</p></blockquote></li><li><p>GRUB： Grand Unified Boot Loader</p><blockquote><p>第一阶段在MBR中，第二节点在/boot/grub中，能够理解文件系统，不需要像LILO一样激活设置，配置文件在/boot/grub/grub.conf，使用grub-install命令进行安装。</p></blockquote></li></ul></li></ul><h3 id="CLI和GUI的对比"><a href="#CLI和GUI的对比" class="headerlink" title="CLI和GUI的对比"></a>CLI和GUI的对比</h3><p>一个是命令行一个是图形化界面</p><h3 id="安装软件命令"><a href="#安装软件命令" class="headerlink" title="安装软件命令"></a>安装软件命令</h3><ul><li><p>从tar压缩包开始</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf application.tar.gz</span><br><span class="line"><span class="built_in">cd</span> application</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">su - </span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>apt-get命令</p></li><li><p>dpkg命令</p></li><li><p>aptitude命令</p></li><li><p>yum+rpm</p></li><li><p>RPM:RPM包管理器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -q -a</span><br><span class="line">rpm -ivh package-name</span><br><span class="line">rpm -e package-name</span><br></pre></td></tr></table></figure></li></ul><h3 id="apt-get原理（没找到）"><a href="#apt-get原理（没找到）" class="headerlink" title="apt-get原理（没找到）"></a>apt-get原理（没找到）</h3><p>老师的pdf里面没找到，可以参考<a href="https://blog.csdn.net/edogawachia/article/details/79263531">CSDN博客</a>，个人感觉写的还可以</p><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><ul><li>passwd：改密码</li><li>mkpasswd：生成一个新的随机密码</li><li>date，cal：获取今天的时间以及显示一个日历</li><li>who，finger：获取在这个系统上活动的其他用户</li><li>clear：清屏</li><li>echo：打印</li><li>write，wall，talk；消息</li><li>pwd：打印工作目录</li><li>cd：更改目录</li><li>mkdir：创建目录</li><li>rmdir：删除目录</li><li>ls：列出目录下的所有内容</li><li>touch：更新文件的访问和/或修改时间</li><li>cp：复制文件</li><li>mv：移动并且重命名文件</li><li>ln：链接文件</li><li>rm： 删除文件</li><li>cat：打印文件的内容</li><li>more/less：每页依次显示文件</li><li>ps：汇报进程状态</li><li>pstree：显示进程树</li><li>jobs，fg，bg，<ctrl-z>： 后台进程控制</li><li>kill：杀进程</li><li>nohup：后台运行</li><li>top：显示CPU头部进程</li></ul><h3 id="七种文件类型"><a href="#七种文件类型" class="headerlink" title="七种文件类型"></a>七种文件类型</h3><ul><li>普通文件<ul><li>文本和数据，没有特别的内部结构</li></ul></li><li>字符设备文件c<ul><li>穿行端口的接口设备，例如键盘、鼠标</li></ul></li><li>块设备文件b<ul><li>存储数据以供系统存取的接口设备，如硬盘</li></ul></li><li>套接字文件s<ul><li>用在网络数据连接</li></ul></li><li>管道文件p<ul><li>解决多个程序同时存取一个文件造成的错误</li></ul></li><li>链接文件l<ul><li>类似快捷方式</li></ul></li><li>目录文件d<ul><li>文件夹</li></ul></li></ul><h3 id="文件夹组织"><a href="#文件夹组织" class="headerlink" title="文件夹组织"></a>文件夹组织</h3><ul><li>所有的Linux文件夹都在一个统一制式的虚拟的文件系统中</li><li>物理设备都挂载在挂载点上<ul><li>Floppy disks</li><li>Hard disk partition</li><li>CD-ROM drives</li></ul></li><li>没有盘符如A:，C:</li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>三种访问级别<ul><li>用户：User</li><li>用户组：Group</li><li>其他</li></ul></li><li>三种权限<ul><li>r</li><li>w</li><li>x</li></ul></li><li>chmod命令<ul><li>chmod <who operator what> filename</li><li>权限可以运算为数（1，2，4）</li></ul></li><li>默认权限<ul><li>文件的默认权限是644</li><li>目录的默认权限是755</li></ul></li></ul><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><ol><li>文件权限以及类型</li><li>链接计数</li><li>拥有者</li><li>拥有组</li><li>大小</li><li>最后一次修改时间</li><li>文件名</li></ol><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/18.png" alt="ls-l示例"></p><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><ul><li>进程是一个任务</li><li>进程是一个正在执行的程序实例。由执行程序、它的当前值、状态信息以及通过操作系统关系此进程情况的资源组成</li><li>进程是一个地址空间，一个或者多个线程在该地址空间中执行，以及这些线程所需要的系统资源</li></ul><h3 id="Unix层次"><a href="#Unix层次" class="headerlink" title="Unix层次"></a>Unix层次</h3><p>早期的UNIX是一个简单的文件系统。一个进程子系统和一个shell</p><p>分为内核和核外程序</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/1.png" alt=""></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/2.png" alt=""></p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/3.png" alt=""></p><h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><h3 id="要求掌握的命令"><a href="#要求掌握的命令" class="headerlink" title="要求掌握的命令"></a>要求掌握的命令</h3><p>ls, dir, mkdir, mknod, mkfifo, cp, mv, rm, chmod, chown,  chgrp, touch, locate, find, grep, pwd, cd, ar, file, tar, more, less, head, tail ,cat, ps, kill, jobs, fg, bg, nice,  who, whoami, passwd, su, uname, man </p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>详见<a href="https://www.runoob.com/linux/linux-shell-io-redirections.html">菜鸟教程Shell重定向</a></p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>一个进程的输出作为另一个进程的输入</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><ul><li>操作环境的参数</li><li>查看和设置环境变量（echo，env，set）</li></ul><blockquote><p>例如：PATH环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin:/bin:/usr/bin:/usr/X11R6/bin:/home/song/bin</span><br><span class="line">PATH=<span class="variable">$PATH</span>:.</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure></blockquote><h3 id="简单的正则"><a href="#简单的正则" class="headerlink" title="简单的正则"></a>简单的正则</h3><p>详见<a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程|正则表达式</a></p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="Shell的地位、位置"><a href="#Shell的地位、位置" class="headerlink" title="Shell的地位、位置"></a>Shell的地位、位置</h3><p>shell是一个命令解释程序和变成环境，是用户和操作系统之间的接口，作为核外程序存在。</p><h3 id="Shell的功能（没找到）"><a href="#Shell的功能（没找到）" class="headerlink" title="Shell的功能（没找到）"></a>Shell的功能（没找到）</h3><ul><li>命令解释程序<ul><li>Linux的开机启动过程；进程树</li></ul></li><li>独立的程序设计语言解释器<ul><li>KISS</li><li>Reusable tools</li><li>Redirection and pipe</li></ul></li></ul><h3 id="不同种类的Shell"><a href="#不同种类的Shell" class="headerlink" title="不同种类的Shell"></a>不同种类的Shell</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/4.png" alt="不同种类的shell"></p><h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><ol><li>可以直接在命令行中进行输入，但是这种输入方式仅会执行一次脚本</li><li>编写脚本文件（要注意注释和退出码）之后进行执行，执行的方法有<ol><li>sh scropt_file</li><li>chmod +x script_file(chown,chgrp 可选择) &amp;&amp; ./script_file</li><li>source script_file <strong>( or )</strong> .script_file</li></ol></li></ol><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量是用户在shell脚本里面定义的变量</p><p>变量的赋值和使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var=value</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure><p>read命令</p><ul><li><p>用法：read var 或 read</p></li><li><p>参数：-t 5（5秒之内进行输入）-p之后可以指定一个提示，更多参见<a href="https://www.runoob.com/linux/linux-comm-read.html">菜鸟教程read命令</a></p></li><li><p>reply variable</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter your name:&quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello <span class="variable">$name</span>, welcome to my program&quot;</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name:&quot;</span> name <span class="comment">#-p参数，运行徐在read命令行中直接指定一个提示</span></span><br><span class="line"><span class="comment">#如</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter a number&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="引号的用法"><a href="#引号的用法" class="headerlink" title="引号的用法"></a>引号的用法</h3><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p>单引号内的所有字符都保持它本身字符的意思，而不会被bash进行解释，例如使用单引号包住$之后表示的是它本身而不再是bash的变量引用符，\就是本身而不再是bash的转义字符</p><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><p>除了$、`（不是单引号）和\外，双引号内的所有字符将保持字符本身的含义不被bash解释</p><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><p>shell环境提供的变量，通常使用大写字母作为名字</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/5.png" alt="环境变量"></p><h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量"></a>参数变量</h3><p>用于脚本程序如果带有参数的情况</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/6.png" alt="参数变量"></p><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><ul><li>退出码（exit code）</li><li>test命令</li><li>test命令支持的条件测试<ul><li>字符串比较</li><li>算术比较</li><li>与文件有关的条件测试</li><li>逻辑操作</li></ul></li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><div class="table-container"><table><thead><tr><th>字符串比较</th><th>结果</th></tr></thead><tbody><tr><td>str1 = str2</td><td>两个字符串相同则结果为真</td></tr><tr><td>str1 != str2</td><td>两个字符串不相同则结果为真</td></tr><tr><td>-z str</td><td>字符串为空则结果为真</td></tr><tr><td>-n str</td><td>字符串不为空则结果为真</td></tr></tbody></table></div><h4 id="算术比较"><a href="#算术比较" class="headerlink" title="算术比较"></a>算术比较</h4><div class="table-container"><table><thead><tr><th>算术比较</th><th>结果</th></tr></thead><tbody><tr><td>expr1 -eq expr2</td><td>两个表达式相等则结果为真</td></tr><tr><td>expr1 –ne expr2</td><td>两个表达式不相等则结果为真</td></tr><tr><td>expr1 –gt expr2</td><td>expr1 大于expr2 则结果为真</td></tr><tr><td>expr1 –ge expr2</td><td>expr1 大于或等于expr2 则结果为真</td></tr><tr><td>expr1 –lt expr2</td><td>expr1 小于expr2 则结果为真</td></tr><tr><td>expr1 –le expr2</td><td>expr1 小于或等于expr2 则结果为真</td></tr></tbody></table></div><h4 id="与文件有关的条件测试"><a href="#与文件有关的条件测试" class="headerlink" title="与文件有关的条件测试"></a>与文件有关的条件测试</h4><div class="table-container"><table><thead><tr><th>文件条件测试</th><th>结果</th></tr></thead><tbody><tr><td>-e file</td><td>文件存在则结果为真</td></tr><tr><td>-d file</td><td>文件是一个子目录则结果为真</td></tr><tr><td>-f file</td><td>文件是一个普通文件则结果为真</td></tr><tr><td>-s file</td><td>文件的长度不为零则结果为真</td></tr><tr><td>-r file</td><td>文件可读则结果为真</td></tr><tr><td>-w file</td><td>文件可写则结果为真</td></tr><tr><td>-x file</td><td>文件可执行则结果为真</td></tr></tbody></table></div><h4 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h4><div class="table-container"><table><thead><tr><th>逻辑操作</th><th>结果</th></tr></thead><tbody><tr><td>!expr</td><td>逻辑表达式求反</td></tr><tr><td>expr1 -a expr2</td><td>两个逻辑表达式“And”（“与”）</td></tr><tr><td>expr1 -r expr2</td><td>两个逻辑表达式“Or”（“或”）</td></tr></tbody></table></div><h3 id="条件控制语句"><a href="#条件控制语句" class="headerlink" title="条件控制语句"></a>条件控制语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if [ expression ]</span><br><span class="line">then</span><br><span class="line">statements</span><br><span class="line">elif [ expression ]</span><br><span class="line">then</span><br><span class="line">statements</span><br><span class="line">elif …</span><br><span class="line">else</span><br><span class="line">statements</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">. ~/.bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo “Is this morning? Please answer yes or no.”</span><br><span class="line">read answer</span><br><span class="line">if [ “$answer”= “yes”]; then</span><br><span class="line">echo “Good morning”</span><br><span class="line">elif [ “$answer”= “no”]; then</span><br><span class="line">echo “Good afternoon”</span><br><span class="line">else</span><br><span class="line">echo “Sorry, $answer not recognized. Enter yes or no”</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case str in</span><br><span class="line">str1 | str2) statements;;</span><br><span class="line">str3 | str4) statements;;</span><br><span class="line">*) statements;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo “Is this morning? Please answer yes or no.”</span><br><span class="line">read answer</span><br><span class="line">case “$answer”in</span><br><span class="line">yes | y | Yes | YES) echo “Good morning!”;;</span><br><span class="line">no | n | No | NO) echo “Good afternoon!”;;</span><br><span class="line">*) echo “Sorry, answer not recognized.”;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in list</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">for file in $(ls f*.sh); do</span><br><span class="line">lpr $file</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">quit=n</span><br><span class="line">while [ “$quit”!= “y”]; do</span><br><span class="line">read menu_choice</span><br><span class="line">case “$menu_choice”in</span><br><span class="line">a) do_something;;</span><br><span class="line">b) do_anotherthing;;</span><br><span class="line">…</span><br><span class="line">q|Q) quit=y;;</span><br><span class="line">*) echo “Sorry, choice not recognized.”;;</span><br><span class="line">esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=0</span><br><span class="line">while [ &quot;$a&quot; -le &quot;$LIMIT&quot; ]</span><br><span class="line">do</span><br><span class="line">a=$(($a+1))</span><br><span class="line">if [ &quot;$a&quot; -gt 2 ]</span><br><span class="line">then</span><br><span class="line">break # Skip entire rest of loop.</span><br><span class="line">fi</span><br><span class="line">echo -n &quot;$a ”</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until语句"><a href="#until语句" class="headerlink" title="until语句"></a>until语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>不推荐使用until语句，一般使用while循环作为替代</p><h4 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select item in itemlist</span><br><span class="line">do</span><br><span class="line">statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">clear</span><br><span class="line">select item in Continue Finish</span><br><span class="line">do</span><br><span class="line">case “$item”in</span><br><span class="line">Continue) ;;</span><br><span class="line">Finish) break ;;</span><br><span class="line">*) echo “Wrong choice! Please select again!”;;</span><br><span class="line">esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h3><h4 id="命令组合"><a href="#命令组合" class="headerlink" title="命令组合"></a>命令组合</h4><ul><li>分号串联<ul><li>command1;command2;….</li></ul></li><li>条件组合<ul><li>AND命令表（格式：statement1 &amp;&amp; statement2 &amp;&amp; statement3 &amp;&amp; …）</li><li>OR命令表（格式：statement1 || statement2 || statement3 || …）</li></ul></li></ul><h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">statement1</span><br><span class="line">statement2</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">&#123; statement1; statement2 ; …; &#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func()</span><br><span class="line">&#123;</span><br><span class="line">statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部变量使用local关键字。</p><p>函数调用：func para1 para2 …</p><p>返回使用return</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/Linux/7.png" alt="函数样例"></p><h3 id="杂项命令"><a href="#杂项命令" class="headerlink" title="杂项命令"></a>杂项命令</h3><ul><li>break: 从for/while/until循环退出</li><li>continue: 跳到下一个循环继续执行</li><li>exit n: 以退出码”n”退出脚本运行</li><li>return: 函数返回</li><li>export: 将变量导出到shell，使之成为shell的环境变量</li><li>set: 为shell设置参数变量</li><li>unset: 从环境中删除变量或函数</li><li>trap: 指定在收到操作系统信号后执行的动作</li><li>“:”(冒号命令): 空命令</li><li>“.”(句点命令)或source: 在当前shell中执行命令</li></ul><h3 id="算术扩展"><a href="#算术扩展" class="headerlink" title="算术扩展"></a>算术扩展</h3><p>$((…))扩展</p><p>样例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/bin/bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line">while[&quot;$x&quot; -ne 10];do</span><br><span class="line">echo $x</span><br><span class="line">x=$(($x+1))</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>关于shell中的算数可以参考<a href="https://blog.csdn.net/wangwenan1993/article/details/45771817">CSDN博客</a></p><a class="btn-beautify block right red larger" href="https://icimence.cn/2021/04/20/Linux%E7%A8%8B%E8%AE%BE%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/"   title="Linux程设复习提纲（二）"><i class="far fa-hand-point-right"></i><span>Linux程设复习提纲（二）</span></a>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1&quot;&gt;&lt;/a&gt;Chapter 1&lt;/h2&gt;&lt;h3 id=&quot;Linux是怎样的一个系统&quot;&gt;&lt;a href=&quot;#Linux是怎样的一个系</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://icimence.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu中使用docker安装Jenkins</title>
    <link href="https://icimence.cn/2021/03/08/%E5%9C%A8Ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85Jenkins/"/>
    <id>https://icimence.cn/2021/03/08/%E5%9C%A8Ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85Jenkins/</id>
    <published>2021-03-08T09:55:06.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><p>本案例中使用的是<code>Ubuntu20.04LTS</code>。</p><p>本示例中docker使用发文时的最新版本，全部使用默认配置，如需自定义配置，请参考<a href="https://docs.docker.com/engine/install/ubuntu/">官方文档</a></p><h2 id="安装配置步骤"><a href="#安装配置步骤" class="headerlink" title="安装配置步骤"></a>安装配置步骤</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ol><li><p>首先确保卸载所有的老版本docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure></li><li><p>更新apt源，安装仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line"> apt-transport-https \</span><br><span class="line"> ca-certificates \</span><br><span class="line"> curl \</span><br><span class="line"> gnupg</span><br></pre></td></tr></table></figure></li><li><p>增加Docker的官方GPG key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure></li><li><p>安装docker仓库</p><ul><li><p>X86/amd64安装命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">   <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></li><li><p>armhf安装命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">   <span class="string">&quot;deb [arch=armhf signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></li><li><p>arm64安装命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">   <span class="string">&quot;deb [arch=arm64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullces.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></li></ul></li><li><p>安装docker引擎（使用默认版本）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>验证docker安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境说明&quot;&gt;&lt;a href=&quot;#环境说明&quot; class=&quot;headerlink&quot; title=&quot;环境说明&quot;&gt;&lt;/a&gt;环境说明&lt;/h2&gt;&lt;p&gt;本案例中使用的是&lt;code&gt;Ubuntu20.04LTS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本示例中docker使用发文时的最新</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://icimence.cn/tags/Docker/"/>
    
    <category term="Jenkins" scheme="https://icimence.cn/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>商务智能复习提纲（三）</title>
    <link href="https://icimence.cn/2021/01/05/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://icimence.cn/2021/01/05/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-01-04T17:17:49.000Z</published>
    <updated>2022-03-26T14:13:50.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳转链接"><a href="#跳转链接" class="headerlink" title="跳转链接"></a>跳转链接</h2><ul><li><a href="https://icimence.cn/2020/11/13/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89/">商务智能复习提纲（一）</a></li><li><a href="https://icimence.cn/2020/12/08/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/">商务智能复习提纲（二）</a></li></ul><h2 id="数据仓库的设计"><a href="#数据仓库的设计" class="headerlink" title="数据仓库的设计"></a>数据仓库的设计</h2><h3 id="数据仓库设计的由来"><a href="#数据仓库设计的由来" class="headerlink" title="数据仓库设计的由来"></a>数据仓库设计的由来</h3><p>类似于在事务型数据处理中需要做数据库设计，需要在分析型数据处理中做数据仓库设计，所以很多思想是可以使用的，但是设计方式还是有着区别。</p><p>建造数据仓库主要由两部分，一个是与操作型系统结构的设计（ETL），另一个是数据仓库本身的设计。</p><p>OLTP的需求是清晰的，但是数据仓库的需求是开始使用之后才知道，所以无法使用传统的需求驱动的方式进行。</p><h3 id="操作型数据库-VS-数据仓库"><a href="#操作型数据库-VS-数据仓库" class="headerlink" title="操作型数据库 VS. 数据仓库"></a>操作型数据库 VS. 数据仓库</h3><ul><li><p>面向的处理类型不同</p><blockquote><p>面向应用 vs. 面向分析</p></blockquote></li><li><p>面向的需求不同</p><blockquote><p>确定的应用需求 vs. 不确定的分析需求</p></blockquote></li><li><p>系统设计目标不同</p><blockquote><p>事务处理性能 vs. 全局一致的数据环境</p></blockquote></li><li><p>数据来源或系统的输入不同</p><blockquote><p>事务相关数据 vs. 多种多样</p></blockquote></li><li><p>系统设计的方法和步骤不同</p><blockquote><p>SDLC（系统生命周期） vs. CLDS </p></blockquote></li></ul><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/20.png" alt="SDLC和CLDS"></p><h3 id="数据仓库的设计原则"><a href="#数据仓库的设计原则" class="headerlink" title="数据仓库的设计原则"></a>数据仓库的设计原则</h3><p>由于数据仓库的特性（面向主题的、集成的、非易失、时变的），有一下三个原则：</p><h4 id="面向主题原则"><a href="#面向主题原则" class="headerlink" title="面向主题原则"></a>面向主题原则</h4><ul><li><p>建立数据仓库的目的</p><blockquote><p>一般面向管理人员或者是提供决策支持，所以组织设计以用户需要来确定。</p></blockquote></li><li><p>数据仓库中数据的组织方法</p><blockquote><p>数据仓库以主题为设计依据，最终要建立起一个面向主题的分析型环境。</p><p>数据库设计中则是以客体为起点，以客观操作需求为设计依据。</p></blockquote></li></ul><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/21.png" alt="例子"></p><h4 id="数据驱动原则"><a href="#数据驱动原则" class="headerlink" title="数据驱动原则"></a>数据驱动原则</h4><ul><li><p>数据来源是已有数据加工而来的</p><blockquote><p>数据仓库是在数据库基础上开发的，注重ETL，分析，挖掘，提供决策支持</p></blockquote></li></ul><p>因为数据都是已有的，所以一定是从操作型环境出发， 这叫做数据驱动。</p><p>会对数据的联系进行重新考察</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/22.png" alt="例子"></p><h4 id="原型法设计原则"><a href="#原型法设计原则" class="headerlink" title="原型法设计原则"></a>原型法设计原则</h4><ul><li><p>不断变化的分析需求</p><blockquote><p>由于数据仓库的原始需求不明确，一直会发生变化且会增加，所以需要使用原型法来进行数据仓库的开发，从基本框架着手不断丰富与完善整个系统。</p></blockquote></li><li><p>逐步求精的设计过程</p><blockquote><p>开发过程中不断地对数据仓库进行完善，需求也会不断增加，需要协同合作，保证工作效率</p></blockquote></li><li><p>启发方式</p><blockquote><p>开发过程中会出现迭代，根据用户反馈修改数据，反馈的过程贯穿于数据仓库的整个开发生命周期之中。</p></blockquote></li><li><p>需求预测依然十分重要，实际情况通常介于启发和预测两者之间。</p></li></ul><h3 id="从操作型数据开始"><a href="#从操作型数据开始" class="headerlink" title="从操作型数据开始"></a>从操作型数据开始</h3><p>数据从操作型环境移入到数据仓库环境不是简单的抽取，通常这些数据缺乏集成，建立操作型应用是没有考虑过集成问题，每个应用都拥有自己的需求，导致相同的数据以不同的名字出现在各地方，不同的数据以相同的名字出现在不同的地方。</p><p>从操作型环境到数据仓库有三种装在工作：</p><ol><li>装载档案数据</li><li>装载操作型系统中已有的数据</li><li>装载变化（更新）描述符或者文件到数据仓库中。</li></ol><p>还要考虑到存取操作型数据的效率</p><p>数据量的管理（数据集成、多粒度、数据转储）</p><h3 id="过程-数据模型与设计环境"><a href="#过程-数据模型与设计环境" class="headerlink" title="过程/数据模型与设计环境"></a>过程/数据模型与设计环境</h3><h3 id="过程模型（仅适合操作型环境）"><a href="#过程模型（仅适合操作型环境）" class="headerlink" title="过程模型（仅适合操作型环境）"></a>过程模型（仅适合操作型环境）</h3><ul><li>功能分解</li><li>第零层上下文图标</li><li>数据流图</li><li>结构图标</li><li>状态转换图</li><li>HIPO图</li><li>伪代码</li></ul><h3 id="数据模型（两者都适合）"><a href="#数据模型（两者都适合）" class="headerlink" title="数据模型（两者都适合）"></a>数据模型（两者都适合）</h3><h4 id="数据模型的性质"><a href="#数据模型的性质" class="headerlink" title="数据模型的性质"></a>数据模型的性质</h4><ul><li>稳定性分析，根据各个数据数据行的变化特性将这些属性分组</li><li>根据稳定成都讨论逻辑优化物理优化及ETL设计等。</li></ul><h4 id="数据模型与迭代开发"><a href="#数据模型与迭代开发" class="headerlink" title="数据模型与迭代开发"></a>数据模型与迭代开发</h4><p>强烈推荐进行迭代开发（业界成功记录推荐），在第一次迭代成功之前用户很难提出清晰的需求。</p><p>数据模型在每一遍开发中都起着路标的作用，在开发结束时，所有遍次的开发结果融合在一起。</p><h3 id="数据仓库设计的三级数据模型"><a href="#数据仓库设计的三级数据模型" class="headerlink" title="数据仓库设计的三级数据模型"></a>数据仓库设计的三级数据模型</h3><ul><li><p>概念模型</p><blockquote><p>为一定目标设计系统、收集信息而服务的概念型工具，是客观世界到机器世界的一个中间层次</p></blockquote></li><li><p>逻辑模型</p><blockquote><ul><li>描述了数据仓库的主题的逻辑实现</li><li>关系模型</li></ul></blockquote></li><li><p>物理模型</p><blockquote><p>逻辑模型在数据仓库中的实现</p></blockquote></li><li><p>高级模型</p><blockquote><ul><li>对数据的抽象程度最大</li><li>ER图</li></ul></blockquote></li><li><p>中极模型</p><blockquote><p>数据项</p></blockquote></li><li><p>低级模型</p><blockquote><p>物理数据模型</p></blockquote></li></ul><h2 id="数据仓库的设计步骤"><a href="#数据仓库的设计步骤" class="headerlink" title="数据仓库的设计步骤"></a>数据仓库的设计步骤</h2><h3 id="系统规划"><a href="#系统规划" class="headerlink" title="系统规划"></a>系统规划</h3><h4 id="明确主题"><a href="#明确主题" class="headerlink" title="明确主题"></a>明确主题</h4><p>数据仓库设计的开始就是要明确主题，这是一个比较高层次的抽象，对他的认知和表示是一个逐步完成的过程（原型设计法）。</p><h4 id="技术准备"><a href="#技术准备" class="headerlink" title="技术准备"></a>技术准备</h4><p>准备技术以及物理实现环境。</p><p>技术评估数据仓库的性能指标（数据存取能力、模型重组能力、数据装载能力）</p><p>准备计算机、网络结构、操作系统、数据库、数据仓库软件。</p><h3 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h3><h4 id="确定系统边界"><a href="#确定系统边界" class="headerlink" title="确定系统边界"></a>确定系统边界</h4><ul><li>要做的决策类型有哪些？</li><li>决策者感兴趣的时什么问题？</li><li>这些问题需要什么样的信息？</li><li>要得到这些信息需要包含哪些数据源？</li></ul><h4 id="确定主要的主题及其内容"><a href="#确定主要的主题及其内容" class="headerlink" title="确定主要的主题及其内容"></a>确定主要的主题及其内容</h4><ul><li>确定主要的主题（明确分析对象，对每个主题的内容进行详细描述）</li><li>在确定上述内容后可以用传统的实体联系模型（ER）来表示数据仓库的概念数据模型。</li></ul><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/24.png" alt="ER图"></p><h4 id="OLAP等分析应用的设计"><a href="#OLAP等分析应用的设计" class="headerlink" title="OLAP等分析应用的设计"></a>OLAP等分析应用的设计</h4><p>PPT中无相关内容</p><h3 id="逻辑设计"><a href="#逻辑设计" class="headerlink" title="逻辑设计"></a>逻辑设计</h3><p>在这个步骤将ER图转换成关系数据库的二维表</p><p>定义数据源和数据抽取规则</p><h4 id="粒度划分"><a href="#粒度划分" class="headerlink" title="粒度划分"></a>粒度划分</h4><p>一般将数据划分为：详细数据、轻度总结、高度总结三种粒度，或者采用更多级的粒度划分方法</p><p>粒度划分将直接影响到数据仓库中的数据量以及所适合的查询类型，会影响仓库的性能。</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/25.png" alt="样例"></p><p>举一个例子，用于商场管理者的数据仓库：</p><div class="table-container"><table><thead><tr><th>主题名</th><th>公共键码</th><th>属性信息</th></tr></thead><tbody><tr><td>商品</td><td>商品号</td><td>固有信息：商品号，商品名，类别，颜色等<br/>采购信息：商品号，供应商号，供应价，供应日期，供应量等<br/>销售信息：商品号，顾客号，售价，销售日期，销售量等<br/>库存信息：商品号，库房号，库存量，日期等</td></tr><tr><td>供应商</td><td>供应商号</td><td>固有信息：供应商号，供应商名，地址，电话，供应商类型等<br/>供应商品信息：供应商号，商品号，供应价，供应日期，供应量等</td></tr><tr><td>顾客</td><td>顾客号</td><td>固有信息：顾客号，姓名，性别，年龄，文化程度，住址，电话等<br/>购物信息：顾客号，商品号，售价，购买日期，购买量等</td></tr></tbody></table></div><h4 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h4><p>把逻辑上是统一整体的数据分割成较小的，可以独立管理的数据单元进行存储，便于重构、重组和回复，提高创建索引和顺序扫描的效率。（常用时间作为分割）</p><p>选择数据分割的因素有</p><ul><li>数据量的大小</li><li>数据分析处理的对象（主题）</li><li>简单易行的数据分割标准</li><li>数据粒度的划分策略</li></ul><p>类似于数据库的分片，目的是提高数据仓库性能。</p><h4 id="定义数据来源"><a href="#定义数据来源" class="headerlink" title="定义数据来源"></a>定义数据来源</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/26.png" alt="数据来源"></p><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><p>具体方法和数据库设计中的大致相似，目的是为了提高数据仓库系统的访问性能。</p><p>常用的技术有：</p><ul><li>合并表</li><li>建立数据序列</li><li>引入冗余</li><li>表的物理分割</li><li>生成导出数据</li><li>建立广义索引</li></ul><h4 id="合并表"><a href="#合并表" class="headerlink" title="合并表"></a>合并表</h4><p>分析处理操作中需要执行表的连接，为了节省开销，直接将记录混合存放，和数据库中的集簇技术类似</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/27.png" alt="合并表"></p><h4 id="数据序列"><a href="#数据序列" class="headerlink" title="数据序列"></a>数据序列</h4><p>创建一个数据序列则一次IO就可以检索，但是需要数列中的值数量稳定、数据按序访问、数据的创建和修改在统计上以非常有规律的方式进行。</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/28.png" alt="数据序列"></p><h4 id="引入冗余"><a href="#引入冗余" class="headerlink" title="引入冗余"></a>引入冗余</h4><p>分析过程有时需要从不同的表访问多个属性，每个属性又能在不同分析过程中使用，所以将某些属性复制到主题表中去减少访问的表的数量</p><p>使用这种方式会有大量的数据冗余，必须保持数据一致性。数据仓库的数据更新比较少，开销较小，所以可以有效提高性能。</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/29.png" alt="引入冗余"></p><h4 id="表的物理分割"><a href="#表的物理分割" class="headerlink" title="表的物理分割"></a>表的物理分割</h4><p>类似于逻辑设计阶段的数据分割，根据表中的数据访问频率和稳定性程度对表的存储结构进行分割。（高频访问、更新的属性单独存储）</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/30.png" alt="物理分割"></p><h4 id="生成导出数据"><a href="#生成导出数据" class="headerlink" title="生成导出数据"></a>生成导出数据</h4><p>在一些细节数据的基础上进行一定的计算和统计，将结果直接保存在数据仓库中，避免分析过程中过多的统计以及不同用户统计的偏差（过于简单，不给图了）</p><h4 id="建立广义索引"><a href="#建立广义索引" class="headerlink" title="建立广义索引"></a>建立广义索引</h4><p>用于记录数据仓库中与“最”有关的统计结果的索引被称为广义索引，数据量非常小，用户直接访问迅速，不再需要对整个仓库进行扫描（过于简单，一样没图）</p><h3 id="数据仓库生成"><a href="#数据仓库生成" class="headerlink" title="数据仓库生成"></a>数据仓库生成</h3><ul><li>建立数据模式</li><li>编制数据抽取程序</li><li>数据加载</li></ul><h3 id="数据仓库的运行和维护"><a href="#数据仓库的运行和维护" class="headerlink" title="数据仓库的运行和维护"></a>数据仓库的运行和维护</h3><p>建立数据仓库之后就可以直接运行分析、决策性应用系统，使用过程中不断加深理解，改进主题（原型法设计），随着数据源的数据的变化刷新数据仓库的数据，保证数据的一致性</p><h3 id="数据仓库的生命周期"><a href="#数据仓库的生命周期" class="headerlink" title="数据仓库的生命周期"></a>数据仓库的生命周期</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/31.png" alt="数据仓库的生命周期"></p><h3 id="数据仓库的设计-生成和运维"><a href="#数据仓库的设计-生成和运维" class="headerlink" title="数据仓库的设计/生成和运维"></a>数据仓库的设计/生成和运维</h3><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/23.png" alt="数据仓库的设计/生成和运维"></p><h2 id="数据仓库设计案例一"><a href="#数据仓库设计案例一" class="headerlink" title="数据仓库设计案例一"></a>数据仓库设计案例一</h2><h3 id="维度建模中的基本概念"><a href="#维度建模中的基本概念" class="headerlink" title="维度建模中的基本概念"></a>维度建模中的基本概念</h3><h4 id="事实表"><a href="#事实表" class="headerlink" title="事实表"></a>事实表</h4><p>维度建模的核心和基本表</p><p>每一事实表都对应着一个或若干个度量值</p><blockquote><p>度量值是事实表的核心，也是趋势分析的对象</p><p>通过事实表来记录纬度值与度量值之间的关系</p></blockquote><p>事实表中的一行对应一个度量值</p><blockquote><ul><li>事实表中的素有度量值必须具有相同的粒度</li><li>粒度划分模型：事务，周期快照，累计快照</li></ul></blockquote><p>事实表中的度量值常用数值类型，很少使用文本</p><p>每个事实表都有两个及以上的外关键字（FK）</p><h4 id="维度表"><a href="#维度表" class="headerlink" title="维度表"></a>维度表</h4><p>维度表是事实表的入口，为用户提供使用数据仓库的接口。</p><p>维度表中的维度属性通常用于定义事实表上的查询条件。</p><p>维度表的定义要尽量多的列和尽可能少的行</p><p>维度表通常是文本数据或者是离散数据</p><p>尽量少使用编码属性</p><p>度量值属性可以参与统计运算，唯独属性一般是离散的，很少发生变化</p><h3 id="维度的规范化处理"><a href="#维度的规范化处理" class="headerlink" title="维度的规范化处理"></a>维度的规范化处理</h3><div class="table-container"><table><thead><tr><th>规范化</th><th>非规范化</th></tr></thead><tbody><tr><td>雪花模型</td><td>星型模型</td></tr><tr><td>复杂的表关系</td><td>简单的表关系</td></tr><tr><td>节省存储空间</td><td>记录之间存在数据冗余</td></tr><tr><td>连接的复杂，高开销</td><td>连接简单，低开销</td></tr><tr><td>低维度浏览能力</td><td>高维度浏览能力</td></tr><tr><td>不支持物理加速技术</td><td>支持物理加速技术</td></tr></tbody></table></div><h2 id="数据仓库设计案例二"><a href="#数据仓库设计案例二" class="headerlink" title="数据仓库设计案例二"></a>数据仓库设计案例二</h2><h3 id="值链"><a href="#值链" class="headerlink" title="值链"></a>值链</h3><ul><li>由企业的关键业务组成</li><li>确定了企业主体活动的自然逻辑流程</li><li>每一步业务处理都产生那个大量的周期性事务记录</li><li>决策支持系统的目标是监控关键处理过程的性能结果</li></ul><h3 id="事实表粒度模型"><a href="#事实表粒度模型" class="headerlink" title="事实表粒度模型"></a>事实表粒度模型</h3><p>有三种互补的粒度模型</p><h4 id="库存周期快照（粒度最大）"><a href="#库存周期快照（粒度最大）" class="headerlink" title="库存周期快照（粒度最大）"></a>库存周期快照（粒度最大）</h4><p>定期生成每种商品的库存水平</p><h4 id="库存事务模型（粒度最小）"><a href="#库存事务模型（粒度最小）" class="headerlink" title="库存事务模型（粒度最小）"></a>库存事务模型（粒度最小）</h4><p>记录影响库存水平的主要因素</p><h4 id="库存累计快照（适中）"><a href="#库存累计快照（适中）" class="headerlink" title="库存累计快照（适中）"></a>库存累计快照（适中）</h4><p>记录每件商品的分发历史，直至其离开仓库</p><h3 id="数据仓库的总线结构"><a href="#数据仓库的总线结构" class="headerlink" title="数据仓库的总线结构"></a>数据仓库的总线结构</h3><ul><li>一种可以按增量开发方法分布建造企业数据仓库的方法</li><li>一组综合的具有一致性的公共维度</li></ul><h3 id="一致性维度"><a href="#一致性维度" class="headerlink" title="一致性维度"></a>一致性维度</h3><ul><li>一致性维度是进一步开发总线结构数据仓库系统的基础</li><li>一致的维度可能意味着是相同的维度表</li><li>大多数一致的维度是在可能的最佳粒度层次上定义的 </li><li>原子型维度</li><li>上钻维度（在较高层次上的维度定义）</li><li>不同业务处理的事实粒度不同</li><li>两个处于相同细节层次上的维度表，如果他们均是另一个维表的子集，则它们也是一致的</li></ul><h3 id="一致性事实"><a href="#一致性事实" class="headerlink" title="一致性事实"></a>一致性事实</h3><ul><li><p>同样的事实在不同的数据备份中进行存储的一致性</p></li><li><p>一般说来，事实表数据不在多个数据备份间明确的进行拷贝</p></li><li><p>如果事实表存在于多个数据备份，那么支撑这些事实的定义和方程必须都是相同的</p></li><li><p>如果无法使事实完全保持一致，那么应该对不同的解释给与不同的名称</p></li></ul><h2 id="数据仓库设计案例三"><a href="#数据仓库设计案例三" class="headerlink" title="数据仓库设计案例三"></a>数据仓库设计案例三</h2><h3 id="事实表的规范化考虑"><a href="#事实表的规范化考虑" class="headerlink" title="事实表的规范化考虑"></a>事实表的规范化考虑</h3><p>事实表的规范化是将一张事实表总的多个度量值分解组装成多个事实表，但是一般不会这么做，因为会添加大量的属性以及计算时的连接操作。</p><p>如果度量值的计算处于不同的粒度上，那么需要将它们分解。</p><p>如果可以将“粗”粒度的度量值分配到“细”的粒度层次上也进行分解。</p><h3 id="三种类型事实表的比较"><a href="#三种类型事实表的比较" class="headerlink" title="三种类型事实表的比较"></a>三种类型事实表的比较</h3><div class="table-container"><table><thead><tr><th><strong>特</strong>   <strong>征</strong></th><th><strong>事务粒度</strong></th><th><strong>周期快照粒度</strong></th><th><strong>累积快照粒度</strong></th></tr></thead><tbody><tr><td><strong>代表的时间段</strong></td><td>时间点</td><td>规律性可预见间隔</td><td>不确定时间跨度，一般是短期</td></tr><tr><td><strong>粒度</strong></td><td>每个事务事件一行</td><td>每段一行</td><td>每个生命期一行</td></tr><tr><td><strong>事实表加载</strong></td><td>插入</td><td>插入</td><td>插入与更新</td></tr><tr><td><strong>事实行更新</strong></td><td>不重新存取</td><td>不重新存取</td><td>行为发生任何时候都要重新存取</td></tr><tr><td><strong>日期维度</strong></td><td>事务发生日期</td><td>时间段终止日期</td><td>标准关键环节的多个日期</td></tr><tr><td><strong>事实</strong></td><td>事务活动</td><td>预定时间间隔的性能</td><td>给定生命期的  性能</td></tr></tbody></table></div><h3 id="实时分区"><a href="#实时分区" class="headerlink" title="实时分区"></a>实时分区</h3><p>有三种不同类型的实时分区</p><h4 id="事务粒度"><a href="#事务粒度" class="headerlink" title="事务粒度"></a>事务粒度</h4><ul><li>实时分区具有与它的支撑静态事实表具有完全相同的维度</li><li>可能完全不建立索引</li><li>避免包含聚集值</li></ul><h4 id="周期粒度"><a href="#周期粒度" class="headerlink" title="周期粒度"></a>周期粒度</h4><ul><li>静态数据仓库事实表具有一个周期粒度，实时分区可以看作是当前的热积月</li><li>实时分区是当前正在开发的月份的映像，随着月份的推进不断更新。半加性或全加性事实随报表不断调整</li><li>月份结束时累计起来的实时分区，作为最新月份加载到静态仓库</li></ul><h4 id="累计快照"><a href="#累计快照" class="headerlink" title="累计快照"></a>累计快照</h4><ul><li>静态数据仓库事实表采用累计快照时，实时分区仅仅包含当天更新的分列项</li><li>当天结束时，实时分区包含了需要写到主要事实表上的记录的最新版本</li><li>无需索引和聚集</li></ul><h2 id="数据仓库设计案例四"><a href="#数据仓库设计案例四" class="headerlink" title="数据仓库设计案例四"></a>数据仓库设计案例四</h2><p>维度表的划分：稳定维度、渐变维度、快变维度。</p><h3 id="渐变维度"><a href="#渐变维度" class="headerlink" title="渐变维度"></a>渐变维度</h3><h4 id="类型1：改写属性值"><a href="#类型1：改写属性值" class="headerlink" title="类型1：改写属性值"></a>类型1：改写属性值</h4><p>直接改变属性值</p><p>容易实现，但不能对旧属性值的任何历史数据进行维护</p><h4 id="类型2：添加维度行"><a href="#类型2：添加维度行" class="headerlink" title="类型2：添加维度行"></a>类型2：添加维度行</h4><p>同名的情况加添加一个新的关键字用于记录新值</p><ul><li>准确跟踪渐变属性的主要方法</li><li>引入新的行用来反映新的属性值</li><li>增加了唯独行的膨胀</li><li>可以引入生效或者截止日期</li></ul><h4 id="类型3：添加维度列"><a href="#类型3：添加维度列" class="headerlink" title="类型3：添加维度列"></a>类型3：添加维度列</h4><ul><li>使用维度列保存旧的属性值</li><li>不适合跟踪唯独属性大量变化</li></ul><h4 id="类型6：1-2-3"><a href="#类型6：1-2-3" class="headerlink" title="类型6：1+2+3"></a>类型6：1+2+3</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/32.png" alt="类型6"></p><h3 id="快变维度"><a href="#快变维度" class="headerlink" title="快变维度"></a>快变维度</h3><h4 id="微型维度"><a href="#微型维度" class="headerlink" title="微型维度"></a>微型维度</h4><p>将分析频率高或变化频率大的属性拆成独立的微型维度（例如：客户维度中的年龄，性别，收入水平等属性，它们的每一种取值组合构成微型维度表中的一行）</p><h4 id="预设波段"><a href="#预设波段" class="headerlink" title="预设波段"></a>预设波段</h4><p>对于诸如收入与购买总额等不断变化的属性，应该被转换成呈波段分布的范围，即进行离散化处理，使其只能在数目相当小的离散值中取值，以减少维度表中的数据量</p><h3 id="体系桥接连表样本行"><a href="#体系桥接连表样本行" class="headerlink" title="体系桥接连表样本行"></a>体系桥接连表样本行</h3><p>体系桥接连表样本行数计算公式：每层的取值数据 * 层深度（从顶层开始计数）然后将乘积相加起来。</p><h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h2><p>有没有懂哥告诉我这个考不考。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跳转链接&quot;&gt;&lt;a href=&quot;#跳转链接&quot; class=&quot;headerlink&quot; title=&quot;跳转链接&quot;&gt;&lt;/a&gt;跳转链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://icimence.cn/2020/11/13/%E5%95%86%E5%8A%</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="商务智能" scheme="https://icimence.cn/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>操作系统问答四</title>
    <link href="https://icimence.cn/2020/12/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E7%AD%94%E5%9B%9B/"/>
    <id>https://icimence.cn/2020/12/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%97%AE%E7%AD%94%E5%9B%9B/</id>
    <published>2020-12-28T07:14:12.000Z</published>
    <updated>2022-03-26T14:13:50.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p><p>从宏观来看，它有自己的目标，或者说功能，同时又能受控于进程调度模块；</p><p>从微观来看，它可以利用系统的资源，有自己的代码和数据，同时拥有自己的堆<br>栈；进程需要被调度。</p><h2 id="进程表是什么"><a href="#进程表是什么" class="headerlink" title="进程表是什么"></a>进程表是什么</h2><p>进程表是存储进程状态信息的数据结构。</p><p>进程表是进程存在的唯一标识，是操作系统用来记录和刻画进程状态及环境信息的数据结构，是进程动态特征的汇集，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据。</p><h2 id="进程栈是什么？"><a href="#进程栈是什么？" class="headerlink" title="进程栈是什么？"></a>进程栈是什么？</h2><p>进程运行时自身的堆栈。</p><h2 id="当寄存器的值已经被保存到进程表内，esp-应指向何处来避免破坏进程表的值？"><a href="#当寄存器的值已经被保存到进程表内，esp-应指向何处来避免破坏进程表的值？" class="headerlink" title="当寄存器的值已经被保存到进程表内，esp 应指向何处来避免破坏进程表的值？"></a>当寄存器的值已经被保存到进程表内，esp 应指向何处来避免破坏进程表的值？</h2><p>进程运行时，esp 指向进程堆栈中的某个位置。寄存器的值刚刚被保存到进程表内，esp 是指向进程表某个位置的。如果接下来进行任何的堆栈操作，都会破坏掉进程表的值。</p><p>为解决这个问题，使用内核栈，让 esp 指向内核栈。</p><h2 id="tty-是什么？"><a href="#tty-是什么？" class="headerlink" title="tty 是什么？"></a>tty 是什么？</h2><p>Teletype 的缩写。终端是一种字符型设备,它有多种类型,通常使用 tty 来简称各种类型的终端设备。</p><p>不同 TTY 对应的输入设备是同一个键盘。</p><h2 id="不同的-tty-为什么输出输出不同的画⾯在同⼀个显⽰器上？"><a href="#不同的-tty-为什么输出输出不同的画⾯在同⼀个显⽰器上？" class="headerlink" title="不同的 tty 为什么输出输出不同的画⾯在同⼀个显⽰器上？"></a>不同的 tty 为什么输出输出不同的画⾯在同⼀个显⽰器上？</h2><p>不同 TTY 各有一个 CONSOLE，各个 CONSOLE 公用同一块显存。</p><p>虽然不同的 TTY 对应的输入设备是同一个键盘，但输出却好比是在不同的显示器上，因为不同的 TTY 对应的屏幕画面可能是迥然不同的。实际上，我们当然是在使用同一个显示器，画面的不同只不过是因为显示了显存的不同位置罢了</p><h2 id="解释-tty-任务执⾏过程？"><a href="#解释-tty-任务执⾏过程？" class="headerlink" title="解释 tty 任务执⾏过程？"></a>解释 tty 任务执⾏过程？</h2><p>在 TTY 任务中执行一个循环，这个循环将轮询每一个 TTY，处理它的事件，包括从键盘缓冲区读取数据、显示字符等内容。</p><p>轮询到每一个 TTY 时：</p><p>处理输入：查看其是否为当前 TTY。只有当某个 TTY 对应的控制台是当前控制台时，它才可以读取键盘缓冲区。</p><p>处理输出：如果有要显示的内容则显示它</p><h2 id="tty-结构体中⼤致包含哪些内容？"><a href="#tty-结构体中⼤致包含哪些内容？" class="headerlink" title="tty 结构体中⼤致包含哪些内容？"></a>tty 结构体中⼤致包含哪些内容？</h2><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/tty.jpg" alt=""></p><h2 id="console-结构体中⼤致包含哪些内容？"><a href="#console-结构体中⼤致包含哪些内容？" class="headerlink" title="console 结构体中⼤致包含哪些内容？"></a>console 结构体中⼤致包含哪些内容？</h2><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/console.jpg" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程是什么&quot;&gt;&lt;a href=&quot;#进程是什么&quot; class=&quot;headerlink&quot; title=&quot;进程是什么&quot;&gt;&lt;/a&gt;进程是什么&lt;/h2&gt;&lt;p&gt;进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。&lt;/p&gt;
&lt;p&gt;从宏观来看，</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="OS" scheme="https://icimence.cn/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>MacOS安装HomeBrew缓慢或出现443的解决办法</title>
    <link href="https://icimence.cn/2020/12/09/MacOS%E5%AE%89%E8%A3%85HomeBrew%E7%BC%93%E6%85%A2%E6%88%96%E5%87%BA%E7%8E%B0443%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://icimence.cn/2020/12/09/MacOS%E5%AE%89%E8%A3%85HomeBrew%E7%BC%93%E6%85%A2%E6%88%96%E5%87%BA%E7%8E%B0443%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2020-12-09T12:49:05.000Z</published>
    <updated>2022-03-26T14:13:50.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用国内镜像安装即可，使用gitee（码云）上的代理脚本进行安装就可以避免这种问题的出现。</p><p>代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>在终端显示多个下载源之后选择一个开始下载，建议使用中科大的下载源。</p><p>按照脚本的提示进行安装，最后会有安装成功的提示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;使用国内镜像安装即可，使用gitee（码云）上的代理脚本进行安装就可以避免这种问题的出现。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;</summary>
      
    
    
    
    <category term="技术笔记" scheme="https://icimence.cn/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="macOS" scheme="https://icimence.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>商务智能复习提纲（二）</title>
    <link href="https://icimence.cn/2020/12/08/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://icimence.cn/2020/12/08/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-12-08T11:09:37.000Z</published>
    <updated>2022-03-26T14:13:50.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳转链接"><a href="#跳转链接" class="headerlink" title="跳转链接"></a>跳转链接</h2><ul><li><a href="https://icimence.cn/2020/11/13/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%80%EF%BC%89/">商务智能复习提纲（一）</a></li><li><a href="https://icimence.cn/2021/01/05/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2%EF%BC%88%E4%B8%89%EF%BC%89/">商务智能复习提纲（三）</a></li></ul><h2 id="数据仓库（二）"><a href="#数据仓库（二）" class="headerlink" title="数据仓库（二）"></a>数据仓库（二）</h2><h3 id="数据集市与数据仓库"><a href="#数据集市与数据仓库" class="headerlink" title="数据集市与数据仓库"></a>数据集市与数据仓库</h3><h4 id="建立数据集市的原因"><a href="#建立数据集市的原因" class="headerlink" title="建立数据集市的原因"></a>建立数据集市的原因</h4><ul><li>在网络环境中可能有很多的数据源，但是没有可用的信息。</li><li>早期的时候只是为用户提供一个访问多个数据源的集成功能。</li></ul><p>但是如果使用数据仓库手机所有的数据会太大，<strong>在实际应用中将它们按部门或个人分别建立反映各个子主题与区域的局部性数据组织，它们即是数据集市。</strong></p><h5 id="数据仓库-数据集市体系"><a href="#数据仓库-数据集市体系" class="headerlink" title="数据仓库/数据集市体系"></a>数据仓库/数据集市体系</h5><p>一个完整的体系结构是由<code>数据源</code>、<code>数据仓库</code>、<code>数据集市</code>构成的</p><p>三者之间通过数据仓库管理软件联系起来构成一个完整的数据体系。</p><p>数据集市的数据来源于数据仓库，对数据仓库中的数据再次进行了抽取和组织，用来满足特定的需求。</p><p>有面向主题、存储了预聚集数据、特定分析需求或用户群快速获取信息、体现终端用户的观点，面向数据仓库的界面、多层次、多维度的特点。</p><p>数据集市有独立性数据集市和从属性数据集市。</p><h4 id="数据仓库与数据集市的关系"><a href="#数据仓库与数据集市的关系" class="headerlink" title="数据仓库与数据集市的关系"></a>数据仓库与数据集市的关系</h4><h5 id="自顶向下的结构"><a href="#自顶向下的结构" class="headerlink" title="自顶向下的结构"></a>自顶向下的结构</h5><p>从数据源进行抽取之后构建企业数据仓库，之后再基于企业数据仓库构建不同的数据集市然后提供服务。</p><blockquote><p>优点：</p><ul><li>建立数据集市能够减轻DW的访问负载</li><li>各部门可以任意处理数据</li><li>数据转换和整合再DW阶段统一完成</li><li>具备数据缓冲功能</li></ul><p>缺点：</p><ul><li>成本高、见效慢、数据集市间不共享资源。</li></ul></blockquote><h5 id="自底向上的结构"><a href="#自底向上的结构" class="headerlink" title="自底向上的结构"></a>自底向上的结构</h5><p>从数据源之间进行数据集市的构建，然后基于数据集市构建企业数据仓库。</p><blockquote><p>优点：</p><ul><li>见效快、启动资金少</li></ul><p>缺点：</p><ul><li>各个部门都要进行数据清理整合</li><li>可能造成“蜘蛛网”、数据不一致的问题</li><li>总体上并没有节约资金</li></ul></blockquote><h5 id="总线结构的数据集市"><a href="#总线结构的数据集市" class="headerlink" title="总线结构的数据集市"></a>总线结构的数据集市</h5><p>不建立数据仓库直接建立数据集市，数据集市之间通过一种共享维表和事实表的“总线结构”紧密联系在一起。</p><blockquote><p>优点：</p><ul><li>共享维表和事实表，解决了数据集市的许多问题</li></ul><p>缺点：</p><ul><li>这种结构基于多维模型，应用限制于OLAP</li><li>多个数据源直接影响多个集市，造成数据仓库结构不十分稳定</li></ul></blockquote><h5 id="企业级数据集市结构"><a href="#企业级数据集市结构" class="headerlink" title="企业级数据集市结构"></a>企业级数据集市结构</h5><p>没有介绍，只有一张图</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/11.png" alt="企业级数据集市结构"></p><h3 id="数据仓库的应用"><a href="#数据仓库的应用" class="headerlink" title="数据仓库的应用"></a>数据仓库的应用</h3><p>数据资源的利用方式有查询，演绎，归纳（挖掘）。</p><p>有时候会出现数据仓库到操作性环境的数据回流，但是直接操作这些回流是不正常的。</p><blockquote><p>访问限定如下：</p><ul><li><p>从响应时间的角度来考虑，请求数据仓库数据的操作型处理通常不具有在线特性</p></li><li><p>对数据的请求必须是最小量的</p></li><li><p>管理数据仓库所用到的技术（如协议等）必须与管理操作型环境所用到的技术一致</p></li><li><p>从数据仓库取得的、准备传输到操作型环境的数据必须不做或很少的格式化</p></li></ul></blockquote><h4 id="数据仓库的间接访问"><a href="#数据仓库的间接访问" class="headerlink" title="数据仓库的间接访问"></a>数据仓库的间接访问</h4><ul><li><p>航空公司的佣金计算系统。</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/12.png" alt="佣金计算系统"></p></li><li><p>零售个性化系统</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/13.png" alt="零售个性化系统"></p></li></ul><p>还可以由一个程序对数据仓库进行定期的分析，检验相关的特征，产生一个小的文件，能够被操作型环境利用。</p><h4 id="分析型应用"><a href="#分析型应用" class="headerlink" title="分析型应用"></a>分析型应用</h4><h5 id="客户关系管理"><a href="#客户关系管理" class="headerlink" title="客户关系管理"></a>客户关系管理</h5><p>包括了客户数据集成（对客户的信息进行分析，让姓名和地址拥有标准的数据格式）以及客户信息的分析与挖掘（新客户的发现，优质客户挖掘，客户异常行为的发现，客户需求分析，客户反映分析）。</p><h5 id="商业零售"><a href="#商业零售" class="headerlink" title="商业零售"></a>商业零售</h5><ul><li>客户信息管理与分析</li><li>销售分析</li><li>货种管理（不同种类商品之间的关系分析）</li><li>市场分析</li><li>库存管理</li><li>人力资源管理</li></ul><h5 id="金融领域"><a href="#金融领域" class="headerlink" title="金融领域"></a>金融领域</h5><ul><li>账户信用等级评估</li><li>信用卡运作</li><li>股票交易规律分析</li><li>财政预算和计划</li></ul><h5 id="保险业"><a href="#保险业" class="headerlink" title="保险业"></a>保险业</h5><ul><li>保险费率的确定</li><li>险种关联分析</li><li>认购险种的预测</li></ul><h5 id="电讯行业"><a href="#电讯行业" class="headerlink" title="电讯行业"></a>电讯行业</h5><ul><li>客户开发</li><li>活动成本管理</li><li>价格定制</li><li>调用详细记录分析</li><li>电信市场</li></ul><h5 id="医疗保健"><a href="#医疗保健" class="headerlink" title="医疗保健"></a>医疗保健</h5><ul><li>成本分析</li><li>客户分类</li></ul><h2 id="联机分析处理（OLAP）"><a href="#联机分析处理（OLAP）" class="headerlink" title="联机分析处理（OLAP）"></a>联机分析处理（OLAP）</h2><h3 id="联机分析处理（OLAP）-1"><a href="#联机分析处理（OLAP）-1" class="headerlink" title="联机分析处理（OLAP）"></a>联机分析处理（OLAP）</h3><p>60年代末提出了联机事务处理（OLTP），随着数据量的增大，兼顾事务操作和分析越来越不可能。</p><p>通过专门的数据综合引擎，同时拥有更加直观的数据访问界面，追求在短时间内相应非专业人士的复杂查询要求。（OLAP）</p><p>OLAP是针对特定问题的练级数据访问和分析，并非是直接的原始数据，已经进行了一定的转换，能够让管理决策人员对数据进行深入观察。</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/13.png" alt="OLAP和OLTP"></p><h3 id="OLAP的特征及衡量标准"><a href="#OLAP的特征及衡量标准" class="headerlink" title="OLAP的特征及衡量标准"></a>OLAP的特征及衡量标准</h3><h4 id="Codd关于OLAP的评价准则"><a href="#Codd关于OLAP的评价准则" class="headerlink" title="Codd关于OLAP的评价准则"></a>Codd关于OLAP的评价准则</h4><ol><li><p>OLAP必须提供多维概念视图。</p><blockquote><p>从多个维度考察对象</p></blockquote></li><li><p>透明性准则</p><blockquote><ul><li>OLAP在体系结构中的位置对用户是透明的</li><li>OLAP的数据源对用户也是透明的</li></ul></blockquote></li><li><p>存取能力准则</p><blockquote><p>将OLAP的概念试图映射到异质的数据存储上，能访问数据并执行所需转换，从而提供单一、完整、连续的用户视图。</p></blockquote></li><li><p>稳定的报表功能</p><blockquote><p>当数据的维度以及数据量增大时，提供给最终分析人员的报表能力和响应速度不应该有明显的上升。</p></blockquote></li><li><p>客户/服务器体系结构</p><blockquote><p>服务i保证透明性和建立统一的公共概念模式、逻辑模式和物理模式。</p><p>客户端负责应用逻辑和界面。</p></blockquote></li><li><p>维的同等性原则</p><blockquote><p>每一个数据维度在数据结构和操作能力上都是等同的。</p></blockquote></li><li><p>动态的稀疏矩阵处理准则</p><blockquote><p>模型的物理模式要适应指定的维数。</p></blockquote></li><li><p>多用户支持能力准则</p><blockquote><p>OLAP工具必须提供并发访问、数据完整性及安全性机制</p></blockquote></li><li><p>非受限的跨维操作</p><blockquote><p>因为数据的维度之间有层次关系，所以进行计算时应该由系统自己推导而不是用户明确定义。</p><p>对于无法计算的内容要提供语言来供用户对计算进行定义。</p></blockquote></li><li><p>直观的数据操作</p></li><li><p>灵活的报表生成</p></li><li><p>不受限维（不小于15）与聚集层次（任意聚集层次）</p></li></ol><h4 id="FASMI评判准则"><a href="#FASMI评判准则" class="headerlink" title="FASMI评判准则"></a>FASMI评判准则</h4><ul><li>fast</li><li>analysis</li><li>shared</li><li>multidimensional</li><li>information</li></ul><h3 id="OLAP中的几个基本概念"><a href="#OLAP中的几个基本概念" class="headerlink" title="OLAP中的几个基本概念"></a>OLAP中的几个基本概念</h3><h4 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h4><p>是分析型处理中所关心的对象，在多维数据集中一般是数字值，是最终用户浏览多维数据集时重点查看的数据。（销售金额，成本金额）</p><h4 id="维"><a href="#维" class="headerlink" title="维"></a>维</h4><p>是观察度量值的角度（如可以从三个维角度观察销售金额即时间维，商品维，地域维）</p><p>维的一个取值称为该维的一个“维成员”，如果这个维有多个层，维成员也可以是多层次的。（对具有日，月，年三个层次的“时间维”来说，“某年某月某日”、“某年某月”、“某月某日”、“某年”都是其维成员）</p><h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>在分析型环境中可以对度量值从不同深度层面上进行分析与观察，层与维是互相关联的，一个维中可以存在多个层</p><h4 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h4><p>多维数组的定义：（维1，维2，…，维n，变量）</p><p>如果多维数组每个维选定的是一个维成员，会确定一个度量值，这个值或者是该放值得地方我们称其为数据单元。</p><h3 id="OLAP的数据构造方式"><a href="#OLAP的数据构造方式" class="headerlink" title="OLAP的数据构造方式"></a>OLAP的数据构造方式</h3><h4 id="ROLAP（Relational）"><a href="#ROLAP（Relational）" class="headerlink" title="ROLAP（Relational）"></a>ROLAP（Relational）</h4><p>使用传统的关系数据库管理系统进行管理。</p><h4 id="MOLAP（Multi-Dimensional）"><a href="#MOLAP（Multi-Dimensional）" class="headerlink" title="MOLAP（Multi-Dimensional）"></a>MOLAP（Multi-Dimensional）</h4><p>用多维数据库管理系统管理，采用基本数据模式是多维数组</p><p>在MOLAP中事实表是一个多维数组，维的属性值是下标。</p><h4 id="HOLAP-混合联机分析处理"><a href="#HOLAP-混合联机分析处理" class="headerlink" title="HOLAP 混合联机分析处理"></a>HOLAP 混合联机分析处理</h4><p>前两者的融合，在大量数据上获得高效率。同时提供多维数据库和关系数据库。</p><h4 id="前两者的比较"><a href="#前两者的比较" class="headerlink" title="前两者的比较"></a>前两者的比较</h4><div class="table-container"><table><thead><tr><th>MOLAP</th><th>ROLAP</th></tr></thead><tbody><tr><td>专为OLAP所设计</td><td>沿用现有的关系数据库的技术</td></tr><tr><td>性能好、响应速度快</td><td>响应速度比MOLAP慢</td></tr><tr><td>数据装载速度慢</td><td>数据装载速度快</td></tr><tr><td>需要进行预计算，可能导致数据爆炸，维数有限；无法支持维的动态变化</td><td>存储空间耗费小，维数没有限制</td></tr><tr><td>受操作系统平台中文件大小的限制，难以达到TB级(只能10~20g)</td><td>借用RDBMS存储数据，没有文件大小限制</td></tr><tr><td>缺乏数据模型和数据访问的标准</td><td>可以通过结构化查询语言（sql）实现详细数据与概要数据的存储</td></tr><tr><td>支持高性能的决策支持计算:复杂的跨维计算；多用户的读写操作；行级的计算</td><td>不支持有关预计算的读写操作：sql无法完成部分计算；无法完成多行的计算；无法完成维之间的计算</td></tr><tr><td>管理简便</td><td>维护困难</td></tr></tbody></table></div><h4 id="OLAP需解决的问题"><a href="#OLAP需解决的问题" class="headerlink" title="OLAP需解决的问题"></a>OLAP需解决的问题</h4><p>提高对数据的访问效率（查询，更新，ETL）</p><p>ROLAP中提高效率的方法：</p><ul><li>物化视图方式</li><li>索引、集簇</li><li>并行操作</li><li>查询优化（共享排序）</li></ul><h3 id="OLAP的基本数据模型"><a href="#OLAP的基本数据模型" class="headerlink" title="OLAP的基本数据模型"></a>OLAP的基本数据模型</h3><h4 id="MOLAP-多维数据库"><a href="#MOLAP-多维数据库" class="headerlink" title="MOLAP 多维数据库"></a>MOLAP 多维数据库</h4><p>使用多维数据库来存放、展示数据，这样存放比关系型数据表更清晰且占用少。但是维护需要大量的资源。</p><p>多维数据库中存取的是经过压缩的类似于数组的对象，带有高度压缩的索引和指针。使用多维查询语言MDSQL。</p><h4 id="ROLAP"><a href="#ROLAP" class="headerlink" title="ROLAP"></a>ROLAP</h4><p>使用通用的关系数据库来存储所需的数据，适用于处理大量数据，但是效率较低。现代的关系型数据库的并发已经有了很好的优化。</p><h5 id="星型模式"><a href="#星型模式" class="headerlink" title="星型模式"></a>星型模式</h5><p>是一种多维表结构，他一般有两种不同性质二维表组成。</p><blockquote><p>事实表（Fact table）</p><blockquote><p>存放多维表中的主要事实，称为度量值（Measure）</p></blockquote><p>维表（Dimension Table）</p><blockquote><p>存放多维表中的维成员的取值    </p></blockquote></blockquote><p>一般一个n维的多维表往往有n个维表和一个事实表，它们构成了一个星形结构，因而称其为“星型模式”</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/15.png" alt="星型模式"></p><p>上图中销售表相当于事实表，其他三个都是维表。</p><h5 id="雪花模式"><a href="#雪花模式" class="headerlink" title="雪花模式"></a>雪花模式</h5><p>是对星型模式的扩展，唯有的维表可变为事实表，形成局部的层次结构。</p><p>让维表更加规范，减少维表的数据量，但是查询会变慢</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/16.png" alt="雪花模式"></p><h5 id="星座模型"><a href="#星座模型" class="headerlink" title="星座模型"></a>星座模型</h5><p>通过公共维度连接多个星型模型</p><h5 id="雪暴模式"><a href="#雪暴模式" class="headerlink" title="雪暴模式"></a>雪暴模式</h5><p>通过公共维度连接多个雪花模式</p><h3 id="数据立方体"><a href="#数据立方体" class="headerlink" title="数据立方体"></a>数据立方体</h3><p>数据仓库中的数据模式可以看成是定义在多个数据源上的数据视图，而需要获取的数据基本上都是统计的数据，如果只是定义函数，然后从视图中取出在计算会耗时，所以使用物化视图（直接将预先计算好数据视图中的统计信息保存在数据仓库中）</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/17.png" alt="雪花模式"></p><p>如果数据的维度超过了3那就是数据超立方体</p><h4 id="方体格"><a href="#方体格" class="headerlink" title="方体格"></a>方体格</h4><p>不太懂，欢迎讨论</p><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/18.png" alt="方体格"></p><h4 id="星形网查询模式"><a href="#星形网查询模式" class="headerlink" title="星形网查询模式"></a>星形网查询模式</h4><p>不太懂，欢迎讨论</p><h4 id="数据立方体的物化"><a href="#数据立方体的物化" class="headerlink" title="数据立方体的物化"></a>数据立方体的物化</h4><ul><li>不进行物化</li><li>全物化（n维L层的立方体包含$T=\prod_{i=1}^n(L_i+1)$种子方）</li><li>部分物化（要注意更新的问题）</li></ul><h4 id="OLAP与数据仓库"><a href="#OLAP与数据仓库" class="headerlink" title="OLAP与数据仓库"></a>OLAP与数据仓库</h4><p><img src="https://icimence-blog.oss-cn-beijing.aliyuncs.com/postimg/BI/19.png" alt="OLAP与数据仓库"></p><h3 id="多维数据分析"><a href="#多维数据分析" class="headerlink" title="多维数据分析"></a>多维数据分析</h3><p>指对以多维形式组织起来的数据进行切片，切块，旋转，钻取等各种分析动作。</p><h4 id="切片（Slice）"><a href="#切片（Slice）" class="headerlink" title="切片（Slice）"></a>切片（Slice）</h4><ul><li>根据某一维上的某个维成员值选择统计数据进行分析</li></ul><h4 id="切块（Dice）"><a href="#切块（Dice）" class="headerlink" title="切块（Dice）"></a>切块（Dice）</h4><ul><li><p>根据某一维上的某个维成员取值的区间选择统计数据进行分析</p></li><li><p>根据多个维度上的维成员取值的区间选择统计数据进行分析</p></li></ul><h4 id="旋转（Pivot-Rotate）"><a href="#旋转（Pivot-Rotate）" class="headerlink" title="旋转（Pivot/Rotate）"></a>旋转（Pivot/Rotate）</h4><ul><li>调整维的排列次序的动作称为旋转</li></ul><h4 id="上钻-数据概括（roll-up）"><a href="#上钻-数据概括（roll-up）" class="headerlink" title="上钻/数据概括（roll_up）"></a>上钻/数据概括（roll_up）</h4><ul><li>将多维下标的取值提升到较高的概念层次上，从而形成新的统计查询结果，并进行分析。</li></ul><h4 id="下钻-数据细化（drill-down）"><a href="#下钻-数据细化（drill-down）" class="headerlink" title="下钻/数据细化（drill_down）"></a>下钻/数据细化（drill_down）</h4><ul><li>将多维下标的取值降低到较低的概念层次上，从而形成更细致的统计查询结果，并进行分析。</li></ul><h4 id="跨钻（drill-across）"><a href="#跨钻（drill-across）" class="headerlink" title="跨钻（drill across）"></a>跨钻（drill across）</h4><ul><li>对多个事实进行操作</li></ul><h4 id="钻透（drill-through）"><a href="#钻透（drill-through）" class="headerlink" title="钻透（drill through）"></a>钻透（drill through）</h4><ul><li>下钻至数据立方体的最低细节后，继续细化至数据仓库/数据库的关系型表格</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;跳转链接&quot;&gt;&lt;a href=&quot;#跳转链接&quot; class=&quot;headerlink&quot; title=&quot;跳转链接&quot;&gt;&lt;/a&gt;跳转链接&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://icimence.cn/2020/11/13/%E5%95%86%E5%8A%</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://icimence.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="商务智能" scheme="https://icimence.cn/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
</feed>
